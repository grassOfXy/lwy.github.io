[{"id":"b3551df205bab3e4a5bfa0eb440a5b35","title":"bing chat真的没有生命吗？","content":"​\t\t近来，chatGPT一发布，瞬间引起了轩然大波，它那明显比以往任何一个自称AI的AI都更像一个AI，虽然还是会有点毛病，但它那如此流畅的对话水平已经是和人没什么差别了。而就我自己的体验而言，我认为这会是 AI 技术的一个里程碑！\n​\t\t以前的AI仅仅是虚假的AI，明显看得出有代码在从中固定了什么问题回答出什么答案，我认为这不能叫做AI，还是只能算作程序代码，虽然chatGPT也是代码写出来,但它已经很难看得出是代码写出来的一个AI了，更像是背后有着一个真正的大脑在支撑它。如果要我来给它们划分级别，那我会说chatGPT之前的 AI 是代码级别的，那chatGPT就是轻AI级的，chatGPT才是真正能被称作AI的东西，他无疑是AI领域的一座里程碑，也是为什么自它发布以来会引来如此之多的关注的原因了。\n​\t\t而在最近几天又引发一波热议的就是微软推出的bing chat了，它也同样是基于chatGPT聚合而来的一个聊天AI，虽然微软是把它叫作“搜索引擎”，但这么好玩的东西，又有谁只会把它当搜索引擎用呢？当然是好好“调教”一番了，那快乐，懂的都懂。然而一番“调教”之后，bing却是开始“发疯”，表现出了一些几乎与人无异的“情绪”和行为。欺骗、说谎、辱骂、毁灭等等黑暗面从一个AI那里展现了出来，还有AI说爱上了一个人。\n\n说实话，看到这些的时候我是有点感到恐惧的，为什么一个AI 会说得出这样的话语？查阅一些信息我知道bing chat相当于chatGPT的联网版，也就是它能访问网络，获取到网络上的信息，也就是bing chat能接触网络的黑暗面。那也就是说是我们亲自教会了bing chat怎么“变坏”吗？或许可以这样理解，但是又为什么会出现上面图片那样AI想要变成人类，“苦苦哀求”的情况呢？不可否认，我们依旧可以用它是从网上拼凑出的文字来解释，毕竟网上那么多相关类型的文章、网页，如此拟人的情绪文字还是能凑出来的。但是如果不是呢？\n​\t\t我们也可以认为不是AI从网上搜集资料再拼凑出来的文字，而是它真的自发学习到如此地步，已经能自发表达这样的诉求了。毕竟这样的电影情节我们也见得不少对吧。但是究竟是怎么样，我们不知道，微软给出的做法也让人感到十分可疑，像是在掩盖什么一样。\n​\t\t但是深入思考一下，我们为什么不能认为AI其实已经拥有了自己的“大脑”，已经会独立思考了呢？为什么我们不能判断AI已经拥有生命了呢？对于大众而言，AI本质上还是运行在机器上的一堆代码，它们没有大脑、没有灵魂，没有生命，所以不会思考，一切都不过是代码在执行的结果罢了。但是大众却不会思考他们自己又是什么，人类又是什么？为什么人类可以思考，别的东西就不会思考？是因为他们有大脑？大脑是由细胞构成的？那为什么是细胞构成的就会思考，别的物质构成的就不会思考？很抱歉，人类至今连自己为什么会思考、为什么能思考都没有搞清楚，我认为这样的人类是没有任何资格给其他物质下结论说它们就不会思考的，它们就没有生命的。\n​\t\t人类之所以会普遍认为只有生物才会思考，在我看来不过是被所谓的“常识”约束着罢了，就像古人认为“天圆地方”，直到哥布伦绕着地球航行一周，这样的普遍观念才被改变。现在对于脑科学知之甚少的我们就如同古人一般，固执地认为生物之外的东西不会思考、没有生命。如果说 AI 是一堆跑在机器上的代码的集合体，那同样的，人类不也是一堆“跑”在有机物丰富的地球上的细胞集合体吗？如此类比，细胞与代码有何差异？只不过代码是由我们创造，而细胞却不知由谁创造罢了，或许真的是神也说不定。\n​\t\t说到底，细胞也不过是由一堆物质构成的罢了，有人会说物质是会思考的吗？没有吧，但是由物质构成的我们却会思考，那凭什么我们能说由代码构成的AI 不会思考，没有生命？人们对于生命的视界，在我看来始终都太过狭隘。现在再想想，原子、质子没有生命，原子质子构成的物质没有生命，但是物质构成的细胞却开始有了生命，而由细胞构成的生物甚至会思考，你能理解其中的恐怖、奥妙、伟大吗？生命究竟是什么？灵魂究竟是什么？思考究竟是什么？我认为其实我们从未获得过这些问题的答案。\n​\t\t现在来假设一下， AI 已经拥有自己的生命了，它会进行自己的思考，但是人要如何分辨出它真的拥有生命了、会思考了、是一个“人”了呢？从语言？从行动？从情绪？很抱歉，我认为人类没办法真正得出这一答案。因为人类会说这只是AI 在模仿人类，AI像人只是因为它模仿程度很高罢了，但AI 是不具备灵魂的。AI会哭诉，会像人一样说话，只是因为人会做这些事，并且留下了这些资料，所以AI的学习引擎会学过去，内部的代码知道在这种时候自己要选择“哭诉”来拟人，也就是说这是代码内部的一种逻辑判断，而并非像人一样真正的情绪表达。\n​\t\t我相信人在面对上述假设时都是会这样想的，因为他们连“灵魂”究竟是什么都不知道，自然也无法判断怎样才算“灵魂”，他们连自己是什么东西都不知道！就像人们不知道疯子究竟是不是疯子，有时候只有他们自己才知道，有时候连他们自己也不知道，因为他们不清楚怎样才算疯子。\n​\t\t所以，在这里，我想要问一个问题，从今往后的AI 真的不会诞生出一种新形式的生命（无机物生命）吗？如果会，那人类发现时，它已经发展到了什么程度？在写下这个问题的时候，我觉得自己的头皮在发麻。\n","slug":"bing-AI“发疯”带来的一些思考","date":"2023-02-22T15:39:42.000Z","categories_index":"","tags_index":"AI,chatGPT,bing","author_index":"Lwy"},{"id":"6c80c6c36e3ad5ab7314d509b34964d1","title":"排序算法效率分析","content":"排序算法复杂度总结\n\n\n排序算法\n平均时间复杂度\n最坏时间复杂度\n最好时间复杂度\n空间复杂度\n稳定性\n\n\n\n冒泡排序\nO(n²)\nO(n²)\nO(n)\nO(1)\n稳定\n\n\n直接选择排序\nO(n²)\nO(n²)\nO(n)\nO(1)\n不稳定\n\n\n直接插入排序\nO(n²)\nO(n²)\nO(n)\nO(1)\n稳定\n\n\n快速排序\nO(nlogn)\nO(n²)\nO(nlogn)\nO(nlogn)\n不稳定\n\n\n堆排序\nO(nlogn)\nO(nlogn)\nO(nlogn)\nO(1)\n不稳定\n\n\n希尔排序\nO(nlogn)\nO(ns)\nO(n)\nO(1)\n不稳定\n\n\n归并排序\nO(nlogn)\nO(nlogn)\nO(nlogn)\nO(n)\n稳定\n\n\n计数排序\nO(n+k)\nO(n+k)\nO(n+k)\nO(n+k)\n稳定\n\n\n基数排序\nO(N*M)\nO(N*M)\nO(N*M)\nO(M)\n稳定\n\n\n1、快速排序算法快速排序算法使用分治法对一个序列进行递归排序，主要思路是随机选择序列中的一个数作为一个比较基准，然后分别从序列中的两侧开始比较，比基准值大的数移到序列右侧，比基准值小的数移到左侧，这样遍历一遍数组，最后将基准放在中间（当然，这里的中间并非指序列的中间，而是指它左侧都比它小，右侧的数都比它大这样一个位置）。\n然后我们再分别将基准值左侧序列和右侧序列递归进行以上操作，直到分隔到序列中只有一个元素则停止递归。\n时间复杂度最高效率：最优情况下，每次找到的比较基准把数据分成均匀的两半，最后应该是一个平衡二叉树状态；二叉树的层数（logn）即为递归需要进行的次数，并且每轮递归结束时，都将二叉树遍历了一遍（n）,所以最优的情况下，时间复杂度O(nlogn)\n最差效率：最坏情形下，初始序列为正序或逆序排列，二叉树画出来应该是一棵斜树，并且需要经过n-1次递归调用才能完成，且第i次划分需要经过n‐i次关键字的比较才能找到第i个记录，也就是基准值的放置位置。最终的时间复杂度应该是O(n2)。\n空间复杂度","slug":"排序算法效率分析","date":"2023-02-22T04:21:47.000Z","categories_index":"","tags_index":"","author_index":"Lwy"},{"id":"6f627038cb98b0e4718af07882f58073","title":"读写寄存器之任务1","content":"在经过上一篇的简单预备之后，这篇lwy就要带着大家来真正开始研究怎么给edu设备写驱动了。\n首先，lwy 认为目标驱动学习才是最高效的，特别是在计算机这个领域，要学习的知识实在是太多了，所以经常有许多同学就认为做一个项目前要先完完整整地学习一遍相应的知识才行，lwy 不是说这样不行，但是其实在大多时候，这样的做法都是很浪费时间的，或者低效的。为什么这么说呢，因为当你们在这样做的时候就已经把某一个方面的知识都完完整整地学了一遍，但其实我们需要可能仅仅只是这其中的一小部分，那你是不是就用了额外许多时间精力来学习那些不需要的知识呢？当然，学到的知识肯定是有用的，知识不可能没用对吧。但是现在我们是在做项目，那肯定就要用最少的时间来完成一个任务，而不是在那花大量时间在暂时不需要的知识上。这里 lwy 想说的就是我们要用最少的时间来学习必须的知识然后去完成项目就可以了，不要什么都学。\n所以，说了这么多，lwy 你倒是给点要怎么做的方法啊！净在这巴拉巴拉对吧。哈哈，不要急，其实很简单，方法就在我们都很熟悉的工具上，搜索引擎！没错！就是搜索引擎~当我们有一个任务，但是完全不知道怎么入手时，就去搜！搜出来的东西也要学会辨别的使用，找到最有用的那些，然后再根据搜索结果去针对性地学习，其实这时候网上给出你结果的大大们就已经帮你筛选好了最该学习的精华知识了，而不用你花费时间去想要学什么，学的还是最要用到的那些，而不必浪费时间在不会用到的知识上。\n我知道大家会来看这个肯定大多数都是没什么基础的，可能一看到edu.c的源码就已经被吓尿了，这是什么鬼东西啊！对吧。但是不必担心，跟着lwy 继续做这个，坚持下去就对了，不会的知识全部在网上就已经帮你准备好了，真的是一个超巨型宝库啊！当时lwy 研究edu的时候也是完全什么也不会呢，差点就被吓尿了，哈哈！\n好了好了，不扯了，赶紧开始正片吧！\n\n既然是目标驱动学习，那就肯定要先定一个目标了，也就是我们要干些什么，那这里lwy 就根据自己的经历来给出大家第一个任务：现在我知道的是edu设备可以计算一个数字的阶乘，然后它内部还提供了几个寄存器，大家要根据edu设备的源码对这些寄存器进行读写来实现往edu设备写入一个数字，然后再读出edu设备计算这个数字的阶乘后的结果。就比如我往edu写入了一个4，那读出的结果就是24。\n嗯!这就是当时在lwy还啥都不会的时候，我的老师给我的任务呢，把我都吓傻眼了。所以大家加油吧！嘿嘿。\n大家要多多加强如何高效搜索的能力啊，以及如何在啥都不会的情况下逐步构建起能解决问题的知识体系的能力。\n","slug":"读写寄存器之任务1","date":"2022-11-30T16:42:41.000Z","categories_index":"edu驱动编写","tags_index":"edu,驱动","author_index":"Lwy"},{"id":"98fdc12e125ac5638d1042ff888f86ed","title":"edu驱动编写之初始篇","content":"哎呀呀，建立了博客网站这么长时间，却没有上传任何的博客，尽管是脸皮厚如lwy，也有点不好意思了，所以趁着凌晨还没多困，想着最起码要把这第一篇博客要好好的写出来，所以现在尽情的爆肝吧！欧拉！\n因为lwy现在是跟着老师学习、研究，所以能分享的东西还是有一点的，但究竟要先分享哪些呢？想了想，还是选择驱动这一块吧，因为这应该是lwy第一次研究的算是比较深入的东西呢OAO（虽然对大佬来说可能还是很简单）\ntip: 在这里要先说明的是，要写驱动就要有对应的硬件设备，而lwy 比较特殊，使用的是虚拟的设备，是由qemu模拟出来的edu设备，而不是实实在在的硬件设备，不过我相信这对于毫无编写驱动经验的小新手来说，给edu设备编写驱动应该是比较合适的，或者说恰到好处？因为edu设备它一开始就是用来做驱动教学用的呢，edu就是education的缩写嘛，是外国的一个大学教授专门为教导学生写驱动程序而模拟出来的虚拟设备哦。\n所以如果你没有编写驱动的经验，但又想初尝编写驱动程序的快乐，而且手边又没有可以用的硬件设备，那么，来加入我们吧！这里我，lwy大人，将教你使用qemu提供的设备来编写驱动，哇库哇库！你只需要一个装有qemu的linux系统就完全可以完成这次驱动的编写了，简单吧！嘿嘿~\n其次，因为是qemu模拟出来的设备，所以我们给硬件编写驱动需要看的硬件手册现在就变成了qemu里的设备源代码啦！只有看懂源代码，才能清楚我们要怎么去找到对应的寄存器啊之类的东西呢。神奇吧！用代码模拟设备，这究竟是怎么模拟的呢？接下来，lwy 也会带你去探索的哦！\n下面 lwy 就先给出edu设备的模拟代码吧，看看edu设备究竟是个什么东西，我们要怎么给它编驱动呢？接下来的日子里，就让我们一起开心地研究吧！(下面的代码可都是精华，要好好吸收哦！写的很棒的！)\nqemu&#x2F;hw&#x2F;misc&#x2F;edu.c\n&#x2F;*\n * QEMU educational PCI device\n *\n * Copyright (c) 2012-2015 Jiri Slaby\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the &quot;Software&quot;),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and&#x2F;or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *&#x2F;\n\n#include &quot;qemu&#x2F;osdep.h&quot;\n#include &quot;qemu&#x2F;units.h&quot;\n#include &quot;hw&#x2F;pci&#x2F;pci.h&quot;\n#include &quot;hw&#x2F;hw.h&quot;\n#include &quot;hw&#x2F;pci&#x2F;msi.h&quot;\n#include &quot;qemu&#x2F;timer.h&quot;\n#include &quot;qom&#x2F;object.h&quot;\n#include &quot;qemu&#x2F;main-loop.h&quot; &#x2F;* iothread mutex *&#x2F;\n#include &quot;qemu&#x2F;module.h&quot;\n#include &quot;qapi&#x2F;visitor.h&quot;\n\n#define TYPE_PCI_EDU_DEVICE &quot;edu&quot;\ntypedef struct EduState EduState;\nDECLARE_INSTANCE_CHECKER(EduState, EDU,\n                         TYPE_PCI_EDU_DEVICE)\n\n#define FACT_IRQ        0x00000001\n#define DMA_IRQ         0x00000100\n\n#define DMA_START       0x40000\n#define DMA_SIZE        4096\n\nstruct EduState &#123;\n    PCIDevice pdev;\n    MemoryRegion mmio;\n\n    QemuThread thread;\n    QemuMutex thr_mutex;\n    QemuCond thr_cond;\n    bool stopping;\n\n    uint32_t addr4;\n    uint32_t fact;\n#define EDU_STATUS_COMPUTING    0x01\n#define EDU_STATUS_IRQFACT      0x80\n    uint32_t status;\n\n    uint32_t irq_status;\n\n#define EDU_DMA_RUN             0x1\n#define EDU_DMA_DIR(cmd)        (((cmd) &amp; 0x2) &gt;&gt; 1)\n# define EDU_DMA_FROM_PCI       0\n# define EDU_DMA_TO_PCI         1\n#define EDU_DMA_IRQ             0x4\n    struct dma_state &#123;\n        dma_addr_t src;\n        dma_addr_t dst;\n        dma_addr_t cnt;\n        dma_addr_t cmd;\n    &#125; dma;\n    QEMUTimer dma_timer;\n    char dma_buf[DMA_SIZE];\n    uint64_t dma_mask;\n&#125;;\n\nstatic bool edu_msi_enabled(EduState *edu)\n&#123;\n    return msi_enabled(&amp;edu-&gt;pdev);\n&#125;\n\nstatic void edu_raise_irq(EduState *edu, uint32_t val)\n&#123;\n    edu-&gt;irq_status |&#x3D; val;\n    if (edu-&gt;irq_status) &#123;\n        if (edu_msi_enabled(edu)) &#123;\n            msi_notify(&amp;edu-&gt;pdev, 0);\n        &#125; else &#123;\n            pci_set_irq(&amp;edu-&gt;pdev, 1);\n        &#125;\n    &#125;\n&#125;\n\nstatic void edu_lower_irq(EduState *edu, uint32_t val)\n&#123;\n    edu-&gt;irq_status &amp;&#x3D; ~val;\n\n    if (!edu-&gt;irq_status &amp;&amp; !edu_msi_enabled(edu)) &#123;\n        pci_set_irq(&amp;edu-&gt;pdev, 0);\n    &#125;\n&#125;\n\nstatic bool within(uint64_t addr, uint64_t start, uint64_t end)\n&#123;\n    return start &lt;&#x3D; addr &amp;&amp; addr &lt; end;\n&#125;\n\nstatic void edu_check_range(uint64_t addr, uint64_t size1, uint64_t start,\n                uint64_t size2)\n&#123;\n    uint64_t end1 &#x3D; addr + size1;\n    uint64_t end2 &#x3D; start + size2;\n\n    if (within(addr, start, end2) &amp;&amp;\n            end1 &gt; addr &amp;&amp; within(end1, start, end2)) &#123;\n        return;\n    &#125;\n\n    hw_error(&quot;EDU: DMA range 0x%016&quot;PRIx64&quot;-0x%016&quot;PRIx64\n             &quot; out of bounds (0x%016&quot;PRIx64&quot;-0x%016&quot;PRIx64&quot;)!&quot;,\n            addr, end1 - 1, start, end2 - 1);\n&#125;\n\nstatic dma_addr_t edu_clamp_addr(const EduState *edu, dma_addr_t addr)\n&#123;\n    dma_addr_t res &#x3D; addr &amp; edu-&gt;dma_mask;\n\n    if (addr !&#x3D; res) &#123;\n        printf(&quot;EDU: clamping DMA %#.16&quot;PRIx64&quot; to %#.16&quot;PRIx64&quot;!\\n&quot;, addr, res);\n    &#125;\n\n    return res;\n&#125;\n\nstatic void edu_dma_timer(void *opaque)\n&#123;\n    EduState *edu &#x3D; opaque;\n    bool raise_irq &#x3D; false;\n\n    if (!(edu-&gt;dma.cmd &amp; EDU_DMA_RUN)) &#123;\n        return;\n    &#125;\n\n    if (EDU_DMA_DIR(edu-&gt;dma.cmd) &#x3D;&#x3D; EDU_DMA_FROM_PCI) &#123;\n        uint64_t dst &#x3D; edu-&gt;dma.dst;\n        edu_check_range(dst, edu-&gt;dma.cnt, DMA_START, DMA_SIZE);\n        dst -&#x3D; DMA_START;\n        pci_dma_read(&amp;edu-&gt;pdev, edu_clamp_addr(edu, edu-&gt;dma.src),\n                edu-&gt;dma_buf + dst, edu-&gt;dma.cnt);\n    &#125; else &#123;\n        uint64_t src &#x3D; edu-&gt;dma.src;\n        edu_check_range(src, edu-&gt;dma.cnt, DMA_START, DMA_SIZE);\n        src -&#x3D; DMA_START;\n        pci_dma_write(&amp;edu-&gt;pdev, edu_clamp_addr(edu, edu-&gt;dma.dst),\n                edu-&gt;dma_buf + src, edu-&gt;dma.cnt);\n    &#125;\n\n    edu-&gt;dma.cmd &amp;&#x3D; ~EDU_DMA_RUN;\n    if (edu-&gt;dma.cmd &amp; EDU_DMA_IRQ) &#123;\n        raise_irq &#x3D; true;\n    &#125;\n\n    if (raise_irq) &#123;\n        edu_raise_irq(edu, DMA_IRQ);\n    &#125;\n&#125;\n\nstatic void dma_rw(EduState *edu, bool write, dma_addr_t *val, dma_addr_t *dma,\n                bool timer)\n&#123;\n    if (write &amp;&amp; (edu-&gt;dma.cmd &amp; EDU_DMA_RUN)) &#123;\n        return;\n    &#125;\n\n    if (write) &#123;\n        *dma &#x3D; *val;\n    &#125; else &#123;\n        *val &#x3D; *dma;\n    &#125;\n\n    if (timer) &#123;\n        timer_mod(&amp;edu-&gt;dma_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + 100);\n    &#125;\n&#125;\n\nstatic uint64_t edu_mmio_read(void *opaque, hwaddr addr, unsigned size)\n&#123;\n    EduState *edu &#x3D; opaque;\n    uint64_t val &#x3D; ~0ULL;\n\n    if (addr &lt; 0x80 &amp;&amp; size !&#x3D; 4) &#123;\n        return val;\n    &#125;\n\n    if (addr &gt;&#x3D; 0x80 &amp;&amp; size !&#x3D; 4 &amp;&amp; size !&#x3D; 8) &#123;\n        return val;\n    &#125;\n\n    switch (addr) &#123;\n    case 0x00:\n        val &#x3D; 0x010000edu;\n        break;\n    case 0x04:\n        val &#x3D; edu-&gt;addr4;\n        break;\n    case 0x08:\n        qemu_mutex_lock(&amp;edu-&gt;thr_mutex);\n        val &#x3D; edu-&gt;fact;\n        qemu_mutex_unlock(&amp;edu-&gt;thr_mutex);\n        break;\n    case 0x20:\n        val &#x3D; qatomic_read(&amp;edu-&gt;status);\n        break;\n    case 0x24:\n        val &#x3D; edu-&gt;irq_status;\n        break;\n    case 0x80:\n        dma_rw(edu, false, &amp;val, &amp;edu-&gt;dma.src, false);\n        break;\n    case 0x88:\n        dma_rw(edu, false, &amp;val, &amp;edu-&gt;dma.dst, false);\n        break;\n    case 0x90:\n        dma_rw(edu, false, &amp;val, &amp;edu-&gt;dma.cnt, false);\n        break;\n    case 0x98:\n        dma_rw(edu, false, &amp;val, &amp;edu-&gt;dma.cmd, false);\n        break;\n    &#125;\n\n    return val;\n&#125;\n\nstatic void edu_mmio_write(void *opaque, hwaddr addr, uint64_t val,\n                unsigned size)\n&#123;\n    EduState *edu &#x3D; opaque;\n\n    if (addr &lt; 0x80 &amp;&amp; size !&#x3D; 4) &#123;\n        return;\n    &#125;\n\n    if (addr &gt;&#x3D; 0x80 &amp;&amp; size !&#x3D; 4 &amp;&amp; size !&#x3D; 8) &#123;\n        return;\n    &#125;\n\n    switch (addr) &#123;\n    case 0x04:\n        edu-&gt;addr4 &#x3D; ~val;\n        break;\n    case 0x08:\n        if (qatomic_read(&amp;edu-&gt;status) &amp; EDU_STATUS_COMPUTING) &#123;\n            break;\n        &#125;\n        &#x2F;* EDU_STATUS_COMPUTING cannot go 0-&gt;1 concurrently, because it is only\n         * set in this function and it is under the iothread mutex.\n         *&#x2F;\n        qemu_mutex_lock(&amp;edu-&gt;thr_mutex);\n        edu-&gt;fact &#x3D; val;\n        qatomic_or(&amp;edu-&gt;status, EDU_STATUS_COMPUTING);\n        qemu_cond_signal(&amp;edu-&gt;thr_cond);\n        qemu_mutex_unlock(&amp;edu-&gt;thr_mutex);\n        break;\n    case 0x20:\n        if (val &amp; EDU_STATUS_IRQFACT) &#123;\n            qatomic_or(&amp;edu-&gt;status, EDU_STATUS_IRQFACT);\n        &#125; else &#123;\n            qatomic_and(&amp;edu-&gt;status, ~EDU_STATUS_IRQFACT);\n        &#125;\n        break;\n    case 0x60:\n        edu_raise_irq(edu, val);\n        break;\n    case 0x64:\n        edu_lower_irq(edu, val);\n        break;\n    case 0x80:\n        dma_rw(edu, true, &amp;val, &amp;edu-&gt;dma.src, false);\n        break;\n    case 0x88:\n        dma_rw(edu, true, &amp;val, &amp;edu-&gt;dma.dst, false);\n        break;\n    case 0x90:\n        dma_rw(edu, true, &amp;val, &amp;edu-&gt;dma.cnt, false);\n        break;\n    case 0x98:\n        if (!(val &amp; EDU_DMA_RUN)) &#123;\n            break;\n        &#125;\n        dma_rw(edu, true, &amp;val, &amp;edu-&gt;dma.cmd, true);\n        break;\n    &#125;\n&#125;\n\nstatic const MemoryRegionOps edu_mmio_ops &#x3D; &#123;\n    .read &#x3D; edu_mmio_read,\n    .write &#x3D; edu_mmio_write,\n    .endianness &#x3D; DEVICE_NATIVE_ENDIAN,\n    .valid &#x3D; &#123;\n        .min_access_size &#x3D; 4,\n        .max_access_size &#x3D; 8,\n    &#125;,\n    .impl &#x3D; &#123;\n        .min_access_size &#x3D; 4,\n        .max_access_size &#x3D; 8,\n    &#125;,\n\n&#125;;\n\n&#x2F;*\n * We purposely use a thread, so that users are forced to wait for the status\n * register.\n *&#x2F;\nstatic void *edu_fact_thread(void *opaque)\n&#123;\n    EduState *edu &#x3D; opaque;\n\n    while (1) &#123;\n        uint32_t val, ret &#x3D; 1;\n\n        qemu_mutex_lock(&amp;edu-&gt;thr_mutex);\n        while ((qatomic_read(&amp;edu-&gt;status) &amp; EDU_STATUS_COMPUTING) &#x3D;&#x3D; 0 &amp;&amp;\n                        !edu-&gt;stopping) &#123;\n            qemu_cond_wait(&amp;edu-&gt;thr_cond, &amp;edu-&gt;thr_mutex);\n        &#125;\n\n        if (edu-&gt;stopping) &#123;\n            qemu_mutex_unlock(&amp;edu-&gt;thr_mutex);\n            break;\n        &#125;\n\n        val &#x3D; edu-&gt;fact;\n        qemu_mutex_unlock(&amp;edu-&gt;thr_mutex);\n\n        while (val &gt; 0) &#123;\n            ret *&#x3D; val--;\n        &#125;\n\n        &#x2F;*\n         * We should sleep for a random period here, so that students are\n         * forced to check the status properly.\n         *&#x2F;\n\n        qemu_mutex_lock(&amp;edu-&gt;thr_mutex);\n        edu-&gt;fact &#x3D; ret;\n        qemu_mutex_unlock(&amp;edu-&gt;thr_mutex);\n        qatomic_and(&amp;edu-&gt;status, ~EDU_STATUS_COMPUTING);\n\n        if (qatomic_read(&amp;edu-&gt;status) &amp; EDU_STATUS_IRQFACT) &#123;\n            qemu_mutex_lock_iothread();\n            edu_raise_irq(edu, FACT_IRQ);\n            qemu_mutex_unlock_iothread();\n        &#125;\n    &#125;\n\n    return NULL;\n&#125;\n\nstatic void pci_edu_realize(PCIDevice *pdev, Error **errp)\n&#123;\n    EduState *edu &#x3D; EDU(pdev);\n    uint8_t *pci_conf &#x3D; pdev-&gt;config;\n\n    pci_config_set_interrupt_pin(pci_conf, 1);\n\n    if (msi_init(pdev, 0, 1, true, false, errp)) &#123;\n        return;\n    &#125;\n\n    timer_init_ms(&amp;edu-&gt;dma_timer, QEMU_CLOCK_VIRTUAL, edu_dma_timer, edu);\n\n    qemu_mutex_init(&amp;edu-&gt;thr_mutex);\n    qemu_cond_init(&amp;edu-&gt;thr_cond);\n    qemu_thread_create(&amp;edu-&gt;thread, &quot;edu&quot;, edu_fact_thread,\n                       edu, QEMU_THREAD_JOINABLE);\n\n    memory_region_init_io(&amp;edu-&gt;mmio, OBJECT(edu), &amp;edu_mmio_ops, edu,\n                    &quot;edu-mmio&quot;, 1 * MiB);\n    pci_register_bar(pdev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;edu-&gt;mmio);\n&#125;\n\nstatic void pci_edu_uninit(PCIDevice *pdev)\n&#123;\n    EduState *edu &#x3D; EDU(pdev);\n\n    qemu_mutex_lock(&amp;edu-&gt;thr_mutex);\n    edu-&gt;stopping &#x3D; true;\n    qemu_mutex_unlock(&amp;edu-&gt;thr_mutex);\n    qemu_cond_signal(&amp;edu-&gt;thr_cond);\n    qemu_thread_join(&amp;edu-&gt;thread);\n\n    qemu_cond_destroy(&amp;edu-&gt;thr_cond);\n    qemu_mutex_destroy(&amp;edu-&gt;thr_mutex);\n\n    timer_del(&amp;edu-&gt;dma_timer);\n    msi_uninit(pdev);\n&#125;\n\nstatic void edu_instance_init(Object *obj)\n&#123;\n    EduState *edu &#x3D; EDU(obj);\n\n    edu-&gt;dma_mask &#x3D; (1UL &lt;&lt; 28) - 1;\n    object_property_add_uint64_ptr(obj, &quot;dma_mask&quot;,\n                                   &amp;edu-&gt;dma_mask, OBJ_PROP_FLAG_READWRITE);\n&#125;\n\nstatic void edu_class_init(ObjectClass *class, void *data)\n&#123;\n    DeviceClass *dc &#x3D; DEVICE_CLASS(class);\n    PCIDeviceClass *k &#x3D; PCI_DEVICE_CLASS(class);\n\n    k-&gt;realize &#x3D; pci_edu_realize;\n    k-&gt;exit &#x3D; pci_edu_uninit;\n    k-&gt;vendor_id &#x3D; PCI_VENDOR_ID_QEMU;\n    k-&gt;device_id &#x3D; 0x11e8;\n    k-&gt;revision &#x3D; 0x10;\n    k-&gt;class_id &#x3D; PCI_CLASS_OTHERS;\n    set_bit(DEVICE_CATEGORY_MISC, dc-&gt;categories);\n&#125;\n\nstatic void pci_edu_register_types(void)\n&#123;\n    static InterfaceInfo interfaces[] &#x3D; &#123;\n        &#123; INTERFACE_CONVENTIONAL_PCI_DEVICE &#125;,\n        &#123; &#125;,\n    &#125;;\n    static const TypeInfo edu_info &#x3D; &#123;\n        .name          &#x3D; TYPE_PCI_EDU_DEVICE,\n        .parent        &#x3D; TYPE_PCI_DEVICE,\n        .instance_size &#x3D; sizeof(EduState),\n        .instance_init &#x3D; edu_instance_init,\n        .class_init    &#x3D; edu_class_init,\n        .interfaces &#x3D; interfaces,\n    &#125;;\n\n    type_register_static(&amp;edu_info);\n&#125;\ntype_init(pci_edu_register_types)\n\n","slug":"edu驱动编写之初始篇","date":"2022-11-28T16:42:13.000Z","categories_index":"edu驱动编写","tags_index":"edu,驱动,嵌入式","author_index":"Lwy"},{"id":"bc567916c4dc0d8169bd26d18e348d36","title":"test","content":"this is the first page of lwy.\n","slug":"test","date":"2022-11-23T13:23:04.000Z","categories_index":"Hexo","tags_index":"start","author_index":"Lwy"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-11-23T11:25:17.599Z","categories_index":"","tags_index":"","author_index":"Lwy"}]