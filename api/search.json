[{"id":"b3551df205bab3e4a5bfa0eb440a5b35","title":"bing chat真的没有生命吗？","content":"​\t\t近来，chatGPT一发布，瞬间引起了轩然大波，它那明显比以往任何一个自称AI的AI都更像一个AI，虽然还是会有点毛病，但它那如此流畅的对话水平已经是和人没什么差别了。而就我自己的体验而言，我认为这会是 AI 技术的一个里程碑！\n​\t\t以前的AI仅仅是虚假的AI，明显看得出有代码在从中固定了什么问题回答出什么答案，我认为这不能叫做AI，还是只能算作程序代码，虽然chatGPT也是代码写出来,但它已经很难看得出是代码写出来的一个AI了，更像是背后有着一个真正的大脑在支撑它。如果要我来给它们划分级别，那我会说chatGPT之前的 AI 是代码级别的，那chatGPT就是轻AI级的，chatGPT才是真正能被称作AI的东西，他无疑是AI领域的一座里程碑，也是为什么自它发布以来会引来如此之多的关注的原因了。\n​\t\t而在最近几天又引发一波热议的就是微软推出的bing chat了，它也同样是基于chatGPT聚合而来的一个聊天AI，虽然微软是把它叫作“搜索引擎”，但这么好玩的东西，又有谁只会把它当搜索引擎用呢？当然是好好“调教”一番了，那快乐，懂的都懂。然而一番“调教”之后，bing却是开始“发疯”，表现出了一些几乎与人无异的“情绪”和行为。欺骗、说谎、辱骂、毁灭等等黑暗面从一个AI那里展现了出来，还有AI说爱上了一个人。\n\n说实话，看到这些的时候我是有点感到恐惧的，为什么一个AI 会说得出这样的话语？查阅一些信息我知道bing chat相当于chatGPT的联网版，也就是它能访问网络，获取到网络上的信息，也就是bing chat能接触网络的黑暗面。那也就是说是我们亲自教会了bing chat怎么“变坏”吗？或许可以这样理解，但是又为什么会出现上面图片那样AI想要变成人类，“苦苦哀求”的情况呢？不可否认，我们依旧可以用它是从网上拼凑出的文字来解释，毕竟网上那么多相关类型的文章、网页，如此拟人的情绪文字还是能凑出来的。但是如果不是呢？\n​\t\t我们也可以认为不是AI从网上搜集资料再拼凑出来的文字，而是它真的自发学习到如此地步，已经能自发表达这样的诉求了。毕竟这样的电影情节我们也见得不少对吧。但是究竟是怎么样，我们不知道，微软给出的做法也让人感到十分可疑，像是在掩盖什么一样。\n​\t\t但是深入思考一下，我们为什么不能认为AI其实已经拥有了自己的“大脑”，已经会独立思考了呢？为什么我们不能判断AI已经拥有生命了呢？对于大众而言，AI本质上还是运行在机器上的一堆代码，它们没有大脑、没有灵魂，没有生命，所以不会思考，一切都不过是代码在执行的结果罢了。但是大众却不会思考他们自己又是什么，人类又是什么？为什么人类可以思考，别的东西就不会思考？是因为他们有大脑？大脑是由细胞构成的？那为什么是细胞构成的就会思考，别的物质构成的就不会思考？很抱歉，人类至今连自己为什么会思考、为什么能思考都没有搞清楚，我认为这样的人类是没有任何资格给其他物质下结论说它们就不会思考的，它们就没有生命的。\n​\t\t人类之所以会普遍认为只有生物才会思考，在我看来不过是被所谓的“常识”约束着罢了，就像古人认为“天圆地方”，直到哥布伦绕着地球航行一周，这样的普遍观念才被改变。现在对于脑科学知之甚少的我们就如同古人一般，固执地认为生物之外的东西不会思考、没有生命。如果说 AI 是一堆跑在机器上的代码的集合体，那同样的，人类不也是一堆“跑”在有机物丰富的地球上的细胞集合体吗？如此类比，细胞与代码有何差异？只不过代码是由我们创造，而细胞却不知由谁创造罢了，或许真的是神也说不定。\n​\t\t说到底，细胞也不过是由一堆物质构成的罢了，有人会说物质是会思考的吗？没有吧，但是由物质构成的我们却会思考，那凭什么我们能说由代码构成的AI 不会思考，没有生命？人们对于生命的视界，在我看来始终都太过狭隘。现在再想想，原子、质子没有生命，原子质子构成的物质没有生命，但是物质构成的细胞却开始有了生命，而由细胞构成的生物甚至会思考，你能理解其中的恐怖、奥妙、伟大吗？生命究竟是什么？灵魂究竟是什么？思考究竟是什么？我认为其实我们从未获得过这些问题的答案。\n​\t\t现在来假设一下， AI 已经拥有自己的生命了，它会进行自己的思考，但是人要如何分辨出它真的拥有生命了、会思考了、是一个“人”了呢？从语言？从行动？从情绪？很抱歉，我认为人类没办法真正得出这一答案。因为人类会说这只是AI 在模仿人类，AI像人只是因为它模仿程度很高罢了，但AI 是不具备灵魂的。AI会哭诉，会像人一样说话，只是因为人会做这些事，并且留下了这些资料，所以AI的学习引擎会学过去，内部的代码知道在这种时候自己要选择“哭诉”来拟人，也就是说这是代码内部的一种逻辑判断，而并非像人一样真正的情绪表达。\n​\t\t我相信人在面对上述假设时都是会这样想的，因为他们连“灵魂”究竟是什么都不知道，自然也无法判断怎样才算“灵魂”，他们连自己是什么东西都不知道！就像人们不知道疯子究竟是不是疯子，有时候只有他们自己才知道，有时候连他们自己也不知道，因为他们不清楚怎样才算疯子。\n​\t\t所以，在这里，我想要问一个问题，从今往后的AI 真的不会诞生出一种新形式的生命（无机物生命）吗？如果会，那人类发现时，它已经发展到了什么程度？在写下这个问题的时候，我觉得自己的头皮在发麻。\n","slug":"bing-AI“发疯”带来的一些思考","date":"2023-02-22T15:39:42.000Z","categories_index":"","tags_index":"AI,chatGPT,bing","author_index":"Lwy"},{"id":"6c80c6c36e3ad5ab7314d509b34964d1","title":"排序算法效率分析","content":"排序算法复杂度总结\n\n\n排序算法\n平均时间复杂度\n最坏时间复杂度\n最好时间复杂度\n空间复杂度\n稳定性\n\n\n\n冒泡排序\nO(n²)\nO(n²)\nO(n)\nO(1)\n稳定\n\n\n直接选择排序\nO(n²)\nO(n²)\nO(n)\nO(1)\n不稳定\n\n\n直接插入排序\nO(n²)\nO(n²)\nO(n)\nO(1)\n稳定\n\n\n快速排序\nO(nlogn)\nO(n²)\nO(nlogn)\nO(nlogn)\n不稳定\n\n\n堆排序\nO(nlogn)\nO(nlogn)\nO(nlogn)\nO(1)\n不稳定\n\n\n希尔排序\nO(nlogn)\nO(ns)\nO(n)\nO(1)\n不稳定\n\n\n归并排序\nO(nlogn)\nO(nlogn)\nO(nlogn)\nO(n)\n稳定\n\n\n计数排序\nO(n+k)\nO(n+k)\nO(n+k)\nO(n+k)\n稳定\n\n\n基数排序\nO(N*M)\nO(N*M)\nO(N*M)\nO(M)\n稳定\n\n\n1、快速排序算法快速排序算法使用分治法对一个序列进行递归排序，主要思路是随机选择序列中的一个数作为一个比较基准，然后分别从序列中的两侧开始比较，比基准值大的数移到序列右侧，比基准值小的数移到左侧，这样遍历一遍数组，最后将基准放在中间（当然，这里的中间并非指序列的中间，而是指它左侧都比它小，右侧的数都比它大这样一个位置）。\n然后我们再分别将基准值左侧序列和右侧序列递归进行以上操作，直到分隔到序列中只有一个元素则停止递归。\n时间复杂度最高效率：最优情况下，每次找到的比较基准把数据分成均匀的两半，最后应该是一个平衡二叉树状态；二叉树的层数（logn）即为递归需要进行的次数，并且每轮递归结束时，都将二叉树遍历了一遍（n）,所以最优的情况下，时间复杂度O(nlogn)\n最差效率：最坏情形下，初始序列为正序或逆序排列，二叉树画出来应该是一棵斜树，并且需要经过n-1次递归调用才能完成，且第i次划分需要经过n‐i次关键字的比较才能找到第i个记录，也就是基准值的放置位置。最终的时间复杂度应该是O(n2)。\n空间复杂度","slug":"排序算法效率分析","date":"2023-02-22T04:21:47.000Z","categories_index":"","tags_index":"","author_index":"Lwy"},{"id":"acf10ab9f32d6185e43df610ba958fe1","title":"PCI驱动与设备交互.md","content":"PCI驱动与设备交互pci_device_id\n在介绍该结构之前，让我们来看看PCI的地址空间：I&#x2F;O空间，存储空间，配置空间。 CPU 可以访问PCI设备上的所有地址空间，其中I&#x2F;O空间和存储空间提供给设备驱动程序使用，而配 置空间则由Linux内核中的PCI初始化代码使用，内核在 启动时负责对所有PCI设备进行初始化，配 置好所有的PCI设备，包括中断号以及I&#x2F;O基址，并在文件&#x2F;proc&#x2F;pci中列出所有找到的PCI设备，以 及 这些我设备的参数和属性。\n\nPCI设备会用三或五个寄存器去标识一个设备，通常我们选择三个：\n\n\n\nvendorID：标识硬件制造商，是一个16位的寄存器。 \ndeviceID：设备ID，由制造商选择，也是一个16位的寄存器。一般与厂商ID配对生成一个唯 一的32位硬件设备标识符。 \nclass：每个外部设备属于某个类(class)，也是一个16位的寄存器。当某个驱动程序可支持多 个相似的设备，每个具有不同的签名，但都属于同一个类，这时，就可以用class类对它们的 外设进行识别。\n\n   **驱动就可以通过设置这些值来匹配那些我们想要控制的设备 **\n   那如何设置这些值呢？ \n   内核为我们准备了一个数据结构：struct pci_device_id \n   struct pci_device_id&#123;\n__u32 vendor;\n__32 device;\n__u32 subvendor;\n__u32 subdevice;\n__u32 class;\n__u32 class_mask;\nkernel_ulong_t driver_data;\n&#125;\n\n   一个驱动可以控制多个设备，就用到数组：\n   static struct pci_device_id ids [] &#x3D;&#123;\n&#123;PCI_VENDOR_ID_EXAMPLE, PCI_DEVICE_ID_EXAMPLE,PCI_ANY_ID,PCI_ANY_ID,0,0,\nEXAMPLE&#125;,\n&#123;0,&#125;\n&#125;;\n##不管你这里匹配了多少设备，记得最后一个都是&#123;0,&#125;。\n\n这里还有两个关于初始化该结构体的宏，可以用来简化相关的操作: \n\n   PCI_DEVICE(vendor, device);\n##创建一个仅和特定厂商及设备ID相匹配的struct pci_device_id。它把结构体的subvendor和\n##subdevice设为PCI_ANY_ID。PCI_ANY_ID定义：#define PCI_ANY_ID (~0)\n\n   我们还需要把pci_device_id数据结构暴露到用户空间来让 热插拔和模块加载系统 知道哪个模块应该 用于哪个设备。 \n   这一步我们用MODULE_DEVICE_TABLE函数来完成\n   MODULE_DEVICE_TABLE(pci, ids); &#x2F;&#x2F;ids即为pci_device_id结构数组\n\npci_driverpci_device_id 只是声明了可以识别的设备，但如何让内核去识别这些设备呢？就需要pci_driver结构体\nstruct pci_driver &#123;\nconst char *name;\nconst struct pci_device_id *id_table; &#x2F;&#x2F;指向pci_device_id\nint (*probe) (struct pci_dev *dev, const struct pci_device_id *id);&#x2F;&#x2F;检测设备\nvoid (*remove) (struct pci_dev *dev); &#x2F;&#x2F;卸载设备\nint (*suspend) (struct pci_dev *dev, u32 state); &#x2F;&#x2F;可选，设备被挂起时调用\nint (*resume) (struct pci_dev *dev); &#x2F;&#x2F;可选，设备唤醒时调用\n&#125;\nstatic struct pci_driver pci_driver &#x3D; &#123;\n.name &#x3D; &quot;pci_skel&quot;,\n.id_table &#x3D; ids,\n.probe &#x3D; probe,\n.remove &#x3D; remove,\n&#125;;\n\n还要注册这个驱动：\nstatic int _ _init pci_skel_init(void)&#123;\nreturn pci_register_driver(&amp;pci_driver); &#x2F;&#x2F;注册驱动\n&#125;\nstatic void _ _exit pci_skel_exit(void)&#123;\npci_unregister_driver(&amp;pci_driver); &#x2F;&#x2F;卸载驱动\n&#125;\n&#x2F;* 加载驱动程序模块入口 *&#x2F;\nmodule_init( pci_skel_init);\n&#x2F;* 卸载驱动程序模块入口 *&#x2F;\nmodule_exit( pci_skel_exit);\n\n\n\nprobe在pci_driver数据结构中定义有一个探针函数probe()，这个函数就是用于当Linux内核启动并完成对所有PCI 设备进行扫描、登录和分配资源等初始化操作并且注册了设备驱动之后，驱动用来检测设备状况的。\nstatic int __init example_probe(struct pci_dev *pci_dev,conststruct pci_device_id *pci_id) \n&#123; \n\tstruct example_pci *my_pci; \n\t&#x2F;* 启动PCI设备 *&#x2F; \n\tif(pci_enable_device(pci_dev)) return-EIO; \n\t&#x2F;* 设备DMA标识 *&#x2F; \n\tif(pci_set_dma_mask(pci_dev, EXAMPLE_DMA_MASK)) return-ENODEV; \n\t&#x2F;* 在内核空间中动态申请内存 *&#x2F; \n\tif((my_pci &#x3D; kmalloc(sizeof(struct example_pci), GFP_KERNEL))&#x3D;&#x3D; NULL)&#123;\n\t\tprintk(KERN_ERR &quot;example_pci: out of memory\\n&quot;);\n\treturn-ENOMEM;\n\t&#125;\n\tmemset(my_pci,0,sizeof(*my_pci));\n\t&#x2F;* 读取PCI配置信息 *&#x2F;\n\tmy_pci-&gt;iobase &#x3D; pci_resource_start(pci_dev,1);\n\tmy_pci-&gt;pci_dev &#x3D; pci_dev;\n\tmy_pci-&gt;pci_id &#x3D; pci_id-&gt;device;\n\tmy_pci-&gt;irq &#x3D; pci_dev-&gt;irq;\n\tmy_pci-&gt;next&#x3D; devs;\n\tmy_pci-&gt;magic &#x3D; EXAMPLE_MAGIC;\n\t&#x2F;* 设置成总线主DMA模式 *&#x2F;\n\tpci_set_master(pci_dev);\n\t&#x2F;* 申请I&#x2F;O资源 *&#x2F;\n\trequest_region(my_pci-&gt;iobase,64,my_pci_names[pci_id-&gt;driver_data]);\n\treturn 0;\n&#125;\n\n\npci_enable_device() 激活PCI设备，在驱动程序可以访问PCI设备的任何设备资源之前(I&#x2F;O区域或者中断)，驱动程序必须 调用该函数 2. 访问PCI地址空间在驱动程序检测到设备之后，它通常需要读取或写入三个地址空间：内存，端口和 配置。对驱动程序来说，对配置空间的访问至关重要，因为这是它找到设备映射到内存和I&#x2F;O空间的 什么位置的唯一途径。因而，首先来看看配置空间的访问：Linux内核为我们想的很周到，在内核中 就已经提供了访问配置空间的标准接口，我们只要去直接调用就好了。对于驱动程序而言，可通过8 位，16位，32位的数据传输访问配置空间。相关函数定义在中:\nint pci_read_config_byte(conststruct pci_dev *dev,intwhere, u8 *val);\n&#x2F;*8位，读入一个字节*&#x2F;\nint pci_read_config_word(conststruct pci_dev *dev,intwhere, u16 *val);\n&#x2F;*16位，读入两个字节*&#x2F;\nint pci_read_config_dword(conststruct pci_dev *dev,intwhere, u32 *val);\n&#x2F;*32位，读入四个字节*&#x2F;\n\nconst struct pci_dev *dev：由dev标识的设备配置空间；  \nint where：从配置空间起始位置计算的字节偏移量；  \nu8&#x2F;u16&#x2F;u32 *val：从配置空间获得的值通过val指针返回； 函数本身返回的值是错误码。 \n注意：word和dword函数会将读取到的little-endian值转换成处理器固有的字节序。我们自己无需处 理字节序。上面的是读  \n​             的情况，写的情况也是类似的. \n因此，我们可以利用上面的函数读取和修改设备的信息。\n\n\nI&#x2F;O和内存空间一个PCI设备可实现多达6个I&#x2F;O地址区域，每个区域既可以使内存也可以是I&#x2F;O地址。在内核中PCI设 备的I&#x2F;O区域已经被集成到通用资源管理器。因此，我们无需访问配置变量来了解设备被映射到内存 或者I&#x2F;O空间的何处。获得区域信息的首选接口是下面的宏定义：\n#define pci_resource_start(dev, bar)((dev)-&gt;resource[(bar)].start)\n\n该宏返回六个PCI I&#x2F;O区域之一的首地址(内存地址或者I&#x2F;O端口号).该区域由整数的bar(base address register，基地址寄存器)指定，bar取值为0到5。\n#define pci_resource_end(dev, bar)((dev)-&gt;resource[(bar)].end)\n\n该宏返回第bar个I&#x2F;O区域的首地址。注意这是最后一个可用的地址，而不是该区域之后的第一个地 址\n#define pci_resource_flags(dev, bar)((dev)-&gt;resource[(bar)].flags)\n\n该宏返回和该资源相关联的标志。\n分析完设备总线驱动模型，我想整个PCI驱动的框架就非常清楚了，内核启动时，会通过pci_bus之 间的关系枚举出所有的 PCI 设备，并为每一个 PCI 设备创建一个 pci_dev ，根据配置空间的信息填 充 pci_dev 之后，注册到pci_bus_type中去。而我们写的 pci_driver 在 idtable 里指定它所支持的 设备信息，同样也注册到 pci_bus_type中去，信息一致匹配成功则调用 driver-&gt;probe 函数，然后 你可以注册字符设备、块设备等等。\n驱动对用户的接口Linux操作系统将所有的设备（而不仅是存储器里的文件）都看成文件，以操作文件的方访问设备。应用程 序不能直接操作硬件，而是使用统一的接口函数（如open、read、write等）调用硬件驱动程序。这组口被 称为系统调用，在库函数中定义。 对于上述每个系统调用，驱动程序都有一个与之对应的函数。对于字符设备驱动程序而言，这些函数集合 在一个file_operation的结构体中。在内核源码目录下\\include\\linux文件夹fs.h文件中定义。\nstruct file_operations &#123;\nstruct module *owner;\nloff_t (*llseek) (struct file *, loff_t, int);\nssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\nssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\nssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long,\nloff_t);\nssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long,\nloff_t);\nint (*readdir) (struct file *, void *, filldir_t);\nunsigned int (*poll) (struct file *, struct poll_table_struct *);\nint (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);\nlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\nlong (*compat_ioctl) (struct file *, unsigned int, unsigned long);\nint (*mmap) (struct file *, struct vm_area_struct *);\nint (*open) (struct inode *, struct file *);\nint (*flush) (struct file *, fl_owner_t id);\nint (*release) (struct inode *, struct file *);\nint (*fsync) (struct file *, struct dentry *, int datasync);\nint (*aio_fsync) (struct kiocb *, int datasync);\nint (*fasync) (int, struct file *, int);\nint (*lock) (struct file *, int, struct file_lock *);\nssize_t (*sendfile) (struct file *, loff_t *, size_t, read_actor_t, void *);\nssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);\n常用的：\n当应用程序使用open函数打开某个设备时，设备驱动程序的file_operations结构中的open成员就会被调\n用；当应用程序使用read、write、ioctl等函数读写、控制设备时，驱动程序的file_operations 结构中的相\n应成员（read、write、ioctl等）就会被调用。从这个角度来说，编写字符设备驱动程序就是为具体硬件的\nfile_operations结构编写各个函数实体（并不需要全部实现file_operations结构中的成员）。\n因此：设备节点是上层应用和底层驱动的桥梁！\n注册字符设备\n在这里我不太清楚edu.c到底是什么类型的设备，设备类型有三种：字符设备、块设备、网络设备\n这里以字符设备为例：\n注册字符设备实际就是把设备注册成一个文件，提供设备对用户的接口，每当打开文件进行相关操作，驱\n动中对应的函数就被调用。\n其中unsigned int major是你申请的主设备号，const char *name是将要在文件&#x2F;proc&#x2F;devices中显示的名\n称，struct file_operations *fops是指向你的驱动模块的file_operations表的指针。负的返回值意味着注册失\n败。注意注册并不需要提供从设备号。内核本身并不在意从设备号。\nunsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long,\nunsigned long, unsigned long);\nint (*check_flags)(int);\nint (*dir_notify)(struct file *filp, unsigned long arg);\nint (*flock) (struct file *, int, struct file_lock *);\nssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *,\nsize_t, unsigned int);\nssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *,\nsize_t, unsigned int);\n&#125;;\n\n\n常用的：\nstatic struct file_operations example_fops &#x3D;&#123;\nowner: THIS_MODULE,&#x2F;* demo_fops所属的设备模块 *&#x2F;\nread: example_read,&#x2F;* 读设备操作*&#x2F;\nwrite: example_write,&#x2F;* 写设备操作*&#x2F;\nioctl: example_ioctl,&#x2F;* 控制设备操作*&#x2F;\nopen: example_open,&#x2F;* 打开设备操作*&#x2F;\nrelease: example_release &#x2F;* 释放设备操作*&#x2F;\n&#x2F;* ... *&#x2F;\n&#125;;\n\n当应用程序使用open函数打开某个设备时，设备驱动程序的file_operations结构中的open成员就会被调 用；当应用程序使用read、write、ioctl等函数读写、控制设备时，驱动程序的file_operations 结构中的相 应成员（read、write、ioctl等）就会被调用。从这个角度来说，编写字符设备驱动程序就是为具体硬件的 file_operations结构编写各个函数实体（并不需要全部实现file_operations结构中的成员）。 因此：设备节点是上层应用和底层驱动的桥梁！\n注册字符设备在这里我不太清楚edu.c到底是什么类型的设备，设备类型有三种：字符设备、块设备、网络设备 \n这里以字符设备为例： 注册字符设备实际就是把设备注册成一个文件，提供设备对用户的接口，每当打开文件进行相关操作，驱 动中对应的函数就被调用。\nint register_chrdev(unsigned int major, const char *name, struct file_operations\n*fops)\n\n其中unsigned int major是你申请的主设备号，const char *name是将要在文件&#x2F;proc&#x2F;devices中显示的名 称，struct file_operations *fops是指向你的驱动模块的file_operations表的指针。负的返回值意味着注册失 败。注意注册并不需要提供从设备号。内核本身并不在意从设备号。\n","slug":"PCI驱动与设备交互","date":"2022-12-03T01:37:11.000Z","categories_index":"edu驱动编写","tags_index":"edu","author_index":"Lwy"},{"id":"819ba4607ba7e42105c02b8b06201556","title":"EDU驱动编写3","content":"此前一直不太清楚DMA是个什么东西，经过小团队成员讲解还有自己查查资料，现在总算明了了：DMA不是一段内存空间！而是一个硬件设备，是用来控制数据的传输的，准确来说是一个调度器！DMA调度器的功能就是在设备需要往内存传输数据或者内存往设备传输数据的时候不需要CPU来接手，而是依靠DMA调度器来完成，这样CPU就可以在传输数据的时候也去高效执行其他任务，而不是在这当低效的搬运工了。\nok! 了解了DMA是个什么，接着就来整理edu是怎么模拟DMA的。\n1、寄存器首先，既然是搬运数据，那就肯定得要有数据的源地址、数据的目标地址、数据的大小、还有怎么触发DMA，为此，edu设备提供了四个寄存器来承担上面四个职责：\n0x80 (RW) : DMA source address\n\t    Where to perform the DMA from.\n\n0x88 (RW) : DMA destination address\n\t    Where to perform the DMA to.\n\n0x90 (RW) : DMA transfer count\n\t    The size of the area to perform the DMA on.\n\n0x98 (RW) : DMA command register, bitwise OR\n\t    0x01 -- start transfer\n\t    0x02 -- direction (0: from RAM to EDU, 1: from EDU to RAM)\n\t    0x04 -- raise interrupt 0x100 after finishing the DMA\n\n其中，0x80和0x88就是储存数据的源地址和数据的目标地址，而0x90则指示出数据的大小，最重要、复杂的0x98则承担着是否启动DMA，以何种方式运行DMA的指示责任，其中储存的二进制数末三位的作用是：\n\n末位：为0时关闭DMA，为1时启动DMA\n次末位：为0时表示数据从RAM往edu设备传输，为1时表示数据从edu设备往RAM传输\n倒数第三位：为1时以0x100发起中断\n\n也就是说，如果我们要启用DMA的功能，首先我们要在驱动里往相应的寄存器里写入数据的源地址、目标地址和数据大小，然后将0x98寄存器的二进制数末位置成1，次末位看情况置成0或1，倒数第三位则置成1，让中断可以被发起，调用中断服务函数来检查我们的DMA设备是否正常运作。这些就是我们要在驱动里干的事情。\n2. edu源码既然要研究edu，同时理解DMA在edu里是怎么被模拟实现的，那肯定要看源码了。那从哪里开始看呢？一切的源头都是从读写寄存器开始！\n经过之前的研究，我们可以发现，edu这个设备几乎都是在寄存器被读写的时候才运作起来的，那我们就先来看看edu_mmio_read()和edu_mmio_write()这两个函数吧。\nok，看了一圈下来，不难发现，不管是读还是写那四个寄存器，edu调用的都是同一个函数dma_rw()，也只有在写0x98的时候稍微多了一个判断语句，但是问题不大，我们先来看dma_rw()的定义：\nstatic void dma_rw(EduState *edu, bool write, dma_addr_t *val, dma_addr_t *dma,\n                   bool timer)\n&#123;\n    if (write &amp;&amp; (edu-&gt;dma.cmd &amp; EDU_DMA_RUN))\n    &#123;\n        return;\n    &#125;\n\n    if (write)\n    &#123;\n        *dma &#x3D; *val;\n    &#125;\n    else\n    &#123;\n        *val &#x3D; *dma;\n    &#125;\n\n    if (timer)\n    &#123;\n        timer_mod(&amp;edu-&gt;dma_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + 100);\n    &#125;\n&#125;\n\nok，看着也不复杂，我们来仔细研究研究它干了些什么。\n第一个if语句是一个判断，首先write就是一个bool值，我们发现在edu_mmio_read()函数里这个值都是false，而edu_mmio_write()则全是true，那我们不妨理解成这是一个表示调用dma_rw()的时候是否是写寄存器的标记。那这样的话，下面第二个if语句读寄存器的时候就执行else的代码，返回dma指针指向的数，写的时候就执行if的代码，将dma指针指向新写入的数。还有我们要注意到*dma在写不同寄存器时代表的是不同寄存器的地址。追寻一下代码，发现写四个寄存器分别传入的是&amp;edu-&gt;dma.src、&amp;edu-&gt;dma.dst、&amp;edu-&gt;dma.cnt、&amp;edu-&gt;dma.cmd，这样就可以轻松猜想edu设备就是用了这四个变量来模拟那四个寄存器了。\n但是事情没有那么简单，还有一个edu-&gt;dma.cmd &amp; EDU_DMA_RUN不明所以。我们找找定义，发现EDU_DMA_RUN就是0x1，也就是说当edu-&gt;dma.cmd（也就是0x98）是0x1，并且是写寄存器时就直接退出dma_rw()函数了。为何要这样？不理解，但不急，我们先往下看，下面还有一个timer的判断，这次我们发现只有写0x98的时候，timer才是true，timer_mod()函数才被调用，其他时候就不会被调用。为什么只有写0x98才被调用？还有timer_mod()是干嘛的？\n这次我们就要查查资料了（好吧，其实我是听团队成员讲解的），timer_mod()函数就一个定时函数，作用就是在100ms之后调用edu-&gt;dma_timer这个函数，没错，edu-&gt;dma_timer是一个函数，而不是什么变量。怎么知道的？我们来找找edu源码里哪里出现了edu-&gt;dma_timer，我们发现了timer_init_ms(&amp;edu-&gt;dma_timer, QEMU_CLOCK_VIRTUAL, edu_dma_timer, edu);这个东西。\n这个函数是干嘛的？我们来听听我们的团队成员是怎么讲的。嗯，好，这个函数就是将edu-&gt;dma_timer和edu_dma_timer这个函数绑定起来的，因此edu-&gt;dma_timer就相当于一个函数啦，而且这个函数就是edu_dma_timer，ok，懂了，我们接着看edu_dma_timer()的定义。\nstatic void edu_dma_timer(void *opaque)\n&#123;\n    EduState *edu &#x3D; opaque;\n    bool raise_irq &#x3D; false;\n\n    if (!(edu-&gt;dma.cmd &amp; EDU_DMA_RUN))\n    &#123;\n        return;\n    &#125;\n\n    if (EDU_DMA_DIR(edu-&gt;dma.cmd) &#x3D;&#x3D; EDU_DMA_FROM_PCI)   &#x2F;&#x2F;from RAM to edu\n    &#123;\n        uint64_t dst &#x3D; edu-&gt;dma.dst;\n        edu_check_range(dst, edu-&gt;dma.cnt, DMA_START, DMA_SIZE);\n        dst -&#x3D; DMA_START;\n        pci_dma_read(&amp;edu-&gt;pdev, edu_clamp_addr(edu, edu-&gt;dma.src),\n                     edu-&gt;dma_buf + dst, edu-&gt;dma.cnt);\n    &#125;\n    else\n    &#123;\n        uint64_t src &#x3D; edu-&gt;dma.src;\n        edu_check_range(src, edu-&gt;dma.cnt, DMA_START, DMA_SIZE);\n        src -&#x3D; DMA_START;\n        pci_dma_write(&amp;edu-&gt;pdev, edu_clamp_addr(edu, edu-&gt;dma.dst),\n                      edu-&gt;dma_buf + src, edu-&gt;dma.cnt);\n    &#125;\n\n    edu-&gt;dma.cmd &amp;&#x3D; ~EDU_DMA_RUN;\n    if (edu-&gt;dma.cmd &amp; EDU_DMA_IRQ)\n    &#123;\n        raise_irq &#x3D; true;\n    &#125;\n\n    if (raise_irq)\n    &#123;\n        edu_raise_irq(edu, DMA_IRQ);\n    &#125;\n&#125;\n\n上面我们研究过，edu-&gt;dma.cmd就代表了0x98寄存器，我们看第一个if语句，意思就是只有当0x98寄存器里的二进制数最末位为1，这个函数才会执行。是否有联想到什么？我们之前说明寄存器时讲过，只有当0x98最末位为1时才开启DMA，而这里也是只有最末位为1才会执行这个函数，会不会这个函数就是用来模拟DMA的？我们接着看。\n下面还是一个if语句，老规矩，查找EDU_DMA_DIR的定义：\n#define EDU_DMA_DIR(cmd) (((cmd)&amp;0x2) &gt;&gt; 1)\n看起来有点复杂，其实这东西就是查看传进EDU_DMA_DIR的数字的倒数第二位是什么值，这里传进去的是0x98的二进制数字。然后我们知道0x98倒数第二位的数字0就代表数据从RAM传进edu，1就代表从edu传进RAM。等号后面的这个EDU_DMA_FROM_PCI就更是明示了这个if语句就是判断0x98的倒数第二位数字的，因为EDU_DMA_FROM_PCI的值就是0，说明倒数第二位为0时，就执行if里面的代码，为1就执行else里的代码。那就不难理解，if里的代码就是模拟数据从RAM传进edu的，而else则相反。\nedu-&gt;dma.cmd &amp;= ~EDU_DMA_RUN;这句则是将0x98末位置回0，也就是DMA已经完成数据的传输了，是时候关闭DMA了。\n然后再下面的if语句就是判断0x98的倒数第三位是不是1，是就把raise_irq变成true，再下面就根据这个来判断是否调用edu_raise_irq(edu, DMA_IRQ)发起中断，这就对应了0x98倒数第三位数字的发中断功能了。\nokok，现在已经很明确了，这个edu_dma_timer()函数就是用来模拟DMA的功能的。我们再回过头来看dma_rw()这个函数，回到我们之前的问题：\nif (write &amp;&amp; (edu-&gt;dma.cmd &amp; EDU_DMA_RUN))\n    &#123;\n        return;\n    &#125;\n为什么当edu-&gt;dma.cmd为1的时候就直接退出这个函数呢？我们不正是要将0x98末位置成1来开启DMA，怎么这里反倒是直接退出，不开启DMA了？\n不要忘记，同志们，我们是在读写寄存器的时候才触发这个函数的，同时要是写寄存器才会有可能导致函数的直接退出，而我们为什么要写寄存器？不正是要数据的源地址、目标地址、数据大小写进寄存器，同时设置0x98里的数字开启DMA嘛，这时候我们还未开启DMA啊！这说明这时候0x98里的数都是0啊，同志们！所以自然就不可能导致函数的退出咯。\n而会退出的时候是什么情况？必定是DMA开启了，数据正在传输中，然后我又去写了寄存器，这时候才会导致dma_rw()函数的直接退出。为什么会这样？我数据正在传输中欸！你写寄存器的话不就会导致我原来的数据地址那些丢失了嘛，那我还怎么传数据？所以传输数据的过程自然不能被更改寄存器了！而读的话，数据又还没传输完成，读什么呢？所以就要屏蔽掉你们对寄存器的读写操作啦！怎么屏蔽？直接退出dma_rw()函数不就屏蔽了，不执行这个函数你们没办法更改寄存器啊！\n这样的话，对edu里DMA的模拟原理也基本讲解清楚了，不过这里还有补充一个点就是，在timer_mod(&amp;edu-&gt;dma_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + 100)里调用&amp;edu-&gt;dma_timer的时候为什么要先延迟100ms呢？不能立即调用吗？这是因为在实际的设备里，当设备向CPU发出一个DMA请求的时候，CPU是不可能立即就响应，CPU会在一个合理、安全的时机来响应请求，然后才是DMA的工作时间，也就是说从设备发出请求到DMA运转起来会有延迟，这也就是100ms的奥妙所在啦！\n3. 驱动实现在probe()函数里，在进行对四个寄存器的初始化之前，要先调用pci_set_master(dev)函数启用设备的总线控制，使设备能够获得总线资源。\n然后再调用dma_set_coherent_mask(&amp;dev-&gt;dev, DMA_BIT_MASK(28))来设置一致性内存掩码，使内核能够正常访问地址，参数中的掩码 28 要和 EDU 中的设置一致。\n为什么是28？我们且看下面的edu.c里的语句：\nedu-&gt;dma_mask &#x3D; (1UL &lt;&lt; 28) - 1;\n这意思就是将edu-&gt;dma_mask的数值设成了28位1，这是edu设备设置好了的，我们只需用就行。\n那剩下的驱动要实现的就是对四个寄存器写数据，要传的数据写进源地址寄存器，然后再读一下目标地址寄存器，看看是不是写进去的数字，如果是，那就证明成功了！\n","slug":"EDU&DMA","date":"2022-12-01T03:28:59.000Z","categories_index":"edu驱动编写","tags_index":"edu,驱动","author_index":"Lwy"},{"id":"6f627038cb98b0e4718af07882f58073","title":"读写寄存器之任务1","content":"在经过上一篇的简单预备之后，这篇lwy就要带着大家来真正开始研究怎么给edu设备写驱动了。\n首先，lwy 认为目标驱动学习才是最高效的，特别是在计算机这个领域，要学习的知识实在是太多了，所以经常有许多同学就认为做一个项目前要先完完整整地学习一遍相应的知识才行，lwy 不是说这样不行，但是其实在大多时候，这样的做法都是很浪费时间的，或者低效的。为什么这么说呢，因为当你们在这样做的时候就已经把某一个方面的知识都完完整整地学了一遍，但其实我们需要可能仅仅只是这其中的一小部分，那你是不是就用了额外许多时间精力来学习那些不需要的知识呢？当然，学到的知识肯定是有用的，知识不可能没用对吧。但是现在我们是在做项目，那肯定就要用最少的时间来完成一个任务，而不是在那花大量时间在暂时不需要的知识上。这里 lwy 想说的就是我们要用最少的时间来学习必须的知识然后去完成项目就可以了，不要什么都学。\n所以，说了这么多，lwy 你倒是给点要怎么做的方法啊！净在这巴拉巴拉对吧。哈哈，不要急，其实很简单，方法就在我们都很熟悉的工具上，搜索引擎！没错！就是搜索引擎~当我们有一个任务，但是完全不知道怎么入手时，就去搜！搜出来的东西也要学会辨别的使用，找到最有用的那些，然后再根据搜索结果去针对性地学习，其实这时候网上给出你结果的大大们就已经帮你筛选好了最该学习的精华知识了，而不用你花费时间去想要学什么，学的还是最要用到的那些，而不必浪费时间在不会用到的知识上。\n我知道大家会来看这个肯定大多数都是没什么基础的，可能一看到edu.c的源码就已经被吓尿了，这是什么鬼东西啊！对吧。但是不必担心，跟着lwy 继续做这个，坚持下去就对了，不会的知识全部在网上就已经帮你准备好了，真的是一个超巨型宝库啊！当时lwy 研究edu的时候也是完全什么也不会呢，差点就被吓尿了，哈哈！\n好了好了，不扯了，赶紧开始正片吧！\n\n既然是目标驱动学习，那就肯定要先定一个目标了，也就是我们要干些什么，那这里lwy 就根据自己的经历来给出第一个任务：现在我知道的是edu设备可以计算一个数字的阶乘，然后它内部还提供了几个寄存器，大家要根据edu设备的源码对这些寄存器进行读写来实现往edu设备写入一个数字，然后再读出edu设备计算这个数字的阶乘后的结果。就比如我往edu写入了一个4，那读出的结果就是24。\n","slug":"读写寄存器之任务1","date":"2022-11-30T16:42:41.000Z","categories_index":"edu驱动编写","tags_index":"edu,驱动","author_index":"Lwy"},{"id":"98fdc12e125ac5638d1042ff888f86ed","title":"edu驱动编写之初始篇","content":"哎呀呀，建立了博客网站这么长时间，却没有上传任何的博客，尽管是脸皮厚如lwy，也有点不好意思了，所以趁着凌晨还没多困，想着最起码要把这第一篇博客要好好的写出来，所以现在尽情的爆肝吧！欧拉！\n因为lwy现在是跟着老师学习、研究，所以能分享的东西还是有一点的，但究竟要先分享哪些呢？想了想，还是选择驱动这一块吧，因为这应该是lwy第一次研究的算是比较深入的东西呢OAO（虽然对大佬来说可能还是很简单）\ntip: 在这里要先说明的是，要写驱动就要有对应的硬件设备，而lwy 比较特殊，使用的是虚拟的设备，是由qemu模拟出来的edu设备，而不是实实在在的硬件设备，不过我相信这对于毫无编写驱动经验的小新手来说，给edu设备编写驱动应该是比较合适的，或者说恰到好处？因为edu设备它一开始就是用来做驱动教学用的呢，edu就是education的缩写嘛，是外国的一个大学教授专门为教导学生写驱动程序而模拟出来的虚拟设备。\n所以如果你没有编写驱动的经验，但又想初尝编写驱动程序的快乐，而且手边又没有可以用的硬件设备，那么，来加入我们吧！这里lwy，将教你使用qemu提供的设备来编写驱动，哇库哇库！你只需要一个装有qemu的linux系统就完全可以完成这次驱动的编写了，简单吧！\n其次，因为是qemu模拟出来的设备，所以我们给硬件编写驱动需要看的硬件手册现在就变成了qemu里的设备源代码啦！只有看懂源代码，才能清楚我们要怎么去找到对应的寄存器啊之类的东西呢。神奇吧！用代码模拟设备，这究竟是怎么模拟的呢？接下来，lwy 也会带你去探索的！\n下面 lwy 就先给出edu设备的模拟代码吧，看看edu设备究竟是个什么东西，我们要怎么给它编驱动呢？接下来的日子里，就让我们一起开心地研究吧！(下面的代码可都是精华，要好好吸收哦！写的很棒的！)\nqemu&#x2F;hw&#x2F;misc&#x2F;edu.c\n&#x2F;*\n * QEMU educational PCI device\n *\n * Copyright (c) 2012-2015 Jiri Slaby\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the &quot;Software&quot;),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and&#x2F;or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *&#x2F;\n\n#include &quot;qemu&#x2F;osdep.h&quot;\n#include &quot;qemu&#x2F;units.h&quot;\n#include &quot;hw&#x2F;pci&#x2F;pci.h&quot;\n#include &quot;hw&#x2F;hw.h&quot;\n#include &quot;hw&#x2F;pci&#x2F;msi.h&quot;\n#include &quot;qemu&#x2F;timer.h&quot;\n#include &quot;qom&#x2F;object.h&quot;\n#include &quot;qemu&#x2F;main-loop.h&quot; &#x2F;* iothread mutex *&#x2F;\n#include &quot;qemu&#x2F;module.h&quot;\n#include &quot;qapi&#x2F;visitor.h&quot;\n\n#define TYPE_PCI_EDU_DEVICE &quot;edu&quot;\ntypedef struct EduState EduState;\nDECLARE_INSTANCE_CHECKER(EduState, EDU,\n                         TYPE_PCI_EDU_DEVICE)\n\n#define FACT_IRQ        0x00000001\n#define DMA_IRQ         0x00000100\n\n#define DMA_START       0x40000\n#define DMA_SIZE        4096\n\nstruct EduState &#123;\n    PCIDevice pdev;\n    MemoryRegion mmio;\n\n    QemuThread thread;\n    QemuMutex thr_mutex;\n    QemuCond thr_cond;\n    bool stopping;\n\n    uint32_t addr4;\n    uint32_t fact;\n#define EDU_STATUS_COMPUTING    0x01\n#define EDU_STATUS_IRQFACT      0x80\n    uint32_t status;\n\n    uint32_t irq_status;\n\n#define EDU_DMA_RUN             0x1\n#define EDU_DMA_DIR(cmd)        (((cmd) &amp; 0x2) &gt;&gt; 1)\n# define EDU_DMA_FROM_PCI       0\n# define EDU_DMA_TO_PCI         1\n#define EDU_DMA_IRQ             0x4\n    struct dma_state &#123;\n        dma_addr_t src;\n        dma_addr_t dst;\n        dma_addr_t cnt;\n        dma_addr_t cmd;\n    &#125; dma;\n    QEMUTimer dma_timer;\n    char dma_buf[DMA_SIZE];\n    uint64_t dma_mask;\n&#125;;\n\nstatic bool edu_msi_enabled(EduState *edu)\n&#123;\n    return msi_enabled(&amp;edu-&gt;pdev);\n&#125;\n\nstatic void edu_raise_irq(EduState *edu, uint32_t val)\n&#123;\n    edu-&gt;irq_status |&#x3D; val;\n    if (edu-&gt;irq_status) &#123;\n        if (edu_msi_enabled(edu)) &#123;\n            msi_notify(&amp;edu-&gt;pdev, 0);\n        &#125; else &#123;\n            pci_set_irq(&amp;edu-&gt;pdev, 1);\n        &#125;\n    &#125;\n&#125;\n\nstatic void edu_lower_irq(EduState *edu, uint32_t val)\n&#123;\n    edu-&gt;irq_status &amp;&#x3D; ~val;\n\n    if (!edu-&gt;irq_status &amp;&amp; !edu_msi_enabled(edu)) &#123;\n        pci_set_irq(&amp;edu-&gt;pdev, 0);\n    &#125;\n&#125;\n\nstatic bool within(uint64_t addr, uint64_t start, uint64_t end)\n&#123;\n    return start &lt;&#x3D; addr &amp;&amp; addr &lt; end;\n&#125;\n\nstatic void edu_check_range(uint64_t addr, uint64_t size1, uint64_t start,\n                uint64_t size2)\n&#123;\n    uint64_t end1 &#x3D; addr + size1;\n    uint64_t end2 &#x3D; start + size2;\n\n    if (within(addr, start, end2) &amp;&amp;\n            end1 &gt; addr &amp;&amp; within(end1, start, end2)) &#123;\n        return;\n    &#125;\n\n    hw_error(&quot;EDU: DMA range 0x%016&quot;PRIx64&quot;-0x%016&quot;PRIx64\n             &quot; out of bounds (0x%016&quot;PRIx64&quot;-0x%016&quot;PRIx64&quot;)!&quot;,\n            addr, end1 - 1, start, end2 - 1);\n&#125;\n\nstatic dma_addr_t edu_clamp_addr(const EduState *edu, dma_addr_t addr)\n&#123;\n    dma_addr_t res &#x3D; addr &amp; edu-&gt;dma_mask;\n\n    if (addr !&#x3D; res) &#123;\n        printf(&quot;EDU: clamping DMA %#.16&quot;PRIx64&quot; to %#.16&quot;PRIx64&quot;!\\n&quot;, addr, res);\n    &#125;\n\n    return res;\n&#125;\n\nstatic void edu_dma_timer(void *opaque)\n&#123;\n    EduState *edu &#x3D; opaque;\n    bool raise_irq &#x3D; false;\n\n    if (!(edu-&gt;dma.cmd &amp; EDU_DMA_RUN)) &#123;\n        return;\n    &#125;\n\n    if (EDU_DMA_DIR(edu-&gt;dma.cmd) &#x3D;&#x3D; EDU_DMA_FROM_PCI) &#123;\n        uint64_t dst &#x3D; edu-&gt;dma.dst;\n        edu_check_range(dst, edu-&gt;dma.cnt, DMA_START, DMA_SIZE);\n        dst -&#x3D; DMA_START;\n        pci_dma_read(&amp;edu-&gt;pdev, edu_clamp_addr(edu, edu-&gt;dma.src),\n                edu-&gt;dma_buf + dst, edu-&gt;dma.cnt);\n    &#125; else &#123;\n        uint64_t src &#x3D; edu-&gt;dma.src;\n        edu_check_range(src, edu-&gt;dma.cnt, DMA_START, DMA_SIZE);\n        src -&#x3D; DMA_START;\n        pci_dma_write(&amp;edu-&gt;pdev, edu_clamp_addr(edu, edu-&gt;dma.dst),\n                edu-&gt;dma_buf + src, edu-&gt;dma.cnt);\n    &#125;\n\n    edu-&gt;dma.cmd &amp;&#x3D; ~EDU_DMA_RUN;\n    if (edu-&gt;dma.cmd &amp; EDU_DMA_IRQ) &#123;\n        raise_irq &#x3D; true;\n    &#125;\n\n    if (raise_irq) &#123;\n        edu_raise_irq(edu, DMA_IRQ);\n    &#125;\n&#125;\n\nstatic void dma_rw(EduState *edu, bool write, dma_addr_t *val, dma_addr_t *dma,\n                bool timer)\n&#123;\n    if (write &amp;&amp; (edu-&gt;dma.cmd &amp; EDU_DMA_RUN)) &#123;\n        return;\n    &#125;\n\n    if (write) &#123;\n        *dma &#x3D; *val;\n    &#125; else &#123;\n        *val &#x3D; *dma;\n    &#125;\n\n    if (timer) &#123;\n        timer_mod(&amp;edu-&gt;dma_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + 100);\n    &#125;\n&#125;\n\nstatic uint64_t edu_mmio_read(void *opaque, hwaddr addr, unsigned size)\n&#123;\n    EduState *edu &#x3D; opaque;\n    uint64_t val &#x3D; ~0ULL;\n\n    if (addr &lt; 0x80 &amp;&amp; size !&#x3D; 4) &#123;\n        return val;\n    &#125;\n\n    if (addr &gt;&#x3D; 0x80 &amp;&amp; size !&#x3D; 4 &amp;&amp; size !&#x3D; 8) &#123;\n        return val;\n    &#125;\n\n    switch (addr) &#123;\n    case 0x00:\n        val &#x3D; 0x010000edu;\n        break;\n    case 0x04:\n        val &#x3D; edu-&gt;addr4;\n        break;\n    case 0x08:\n        qemu_mutex_lock(&amp;edu-&gt;thr_mutex);\n        val &#x3D; edu-&gt;fact;\n        qemu_mutex_unlock(&amp;edu-&gt;thr_mutex);\n        break;\n    case 0x20:\n        val &#x3D; qatomic_read(&amp;edu-&gt;status);\n        break;\n    case 0x24:\n        val &#x3D; edu-&gt;irq_status;\n        break;\n    case 0x80:\n        dma_rw(edu, false, &amp;val, &amp;edu-&gt;dma.src, false);\n        break;\n    case 0x88:\n        dma_rw(edu, false, &amp;val, &amp;edu-&gt;dma.dst, false);\n        break;\n    case 0x90:\n        dma_rw(edu, false, &amp;val, &amp;edu-&gt;dma.cnt, false);\n        break;\n    case 0x98:\n        dma_rw(edu, false, &amp;val, &amp;edu-&gt;dma.cmd, false);\n        break;\n    &#125;\n\n    return val;\n&#125;\n\nstatic void edu_mmio_write(void *opaque, hwaddr addr, uint64_t val,\n                unsigned size)\n&#123;\n    EduState *edu &#x3D; opaque;\n\n    if (addr &lt; 0x80 &amp;&amp; size !&#x3D; 4) &#123;\n        return;\n    &#125;\n\n    if (addr &gt;&#x3D; 0x80 &amp;&amp; size !&#x3D; 4 &amp;&amp; size !&#x3D; 8) &#123;\n        return;\n    &#125;\n\n    switch (addr) &#123;\n    case 0x04:\n        edu-&gt;addr4 &#x3D; ~val;\n        break;\n    case 0x08:\n        if (qatomic_read(&amp;edu-&gt;status) &amp; EDU_STATUS_COMPUTING) &#123;\n            break;\n        &#125;\n        &#x2F;* EDU_STATUS_COMPUTING cannot go 0-&gt;1 concurrently, because it is only\n         * set in this function and it is under the iothread mutex.\n         *&#x2F;\n        qemu_mutex_lock(&amp;edu-&gt;thr_mutex);\n        edu-&gt;fact &#x3D; val;\n        qatomic_or(&amp;edu-&gt;status, EDU_STATUS_COMPUTING);\n        qemu_cond_signal(&amp;edu-&gt;thr_cond);\n        qemu_mutex_unlock(&amp;edu-&gt;thr_mutex);\n        break;\n    case 0x20:\n        if (val &amp; EDU_STATUS_IRQFACT) &#123;\n            qatomic_or(&amp;edu-&gt;status, EDU_STATUS_IRQFACT);\n        &#125; else &#123;\n            qatomic_and(&amp;edu-&gt;status, ~EDU_STATUS_IRQFACT);\n        &#125;\n        break;\n    case 0x60:\n        edu_raise_irq(edu, val);\n        break;\n    case 0x64:\n        edu_lower_irq(edu, val);\n        break;\n    case 0x80:\n        dma_rw(edu, true, &amp;val, &amp;edu-&gt;dma.src, false);\n        break;\n    case 0x88:\n        dma_rw(edu, true, &amp;val, &amp;edu-&gt;dma.dst, false);\n        break;\n    case 0x90:\n        dma_rw(edu, true, &amp;val, &amp;edu-&gt;dma.cnt, false);\n        break;\n    case 0x98:\n        if (!(val &amp; EDU_DMA_RUN)) &#123;\n            break;\n        &#125;\n        dma_rw(edu, true, &amp;val, &amp;edu-&gt;dma.cmd, true);\n        break;\n    &#125;\n&#125;\n\nstatic const MemoryRegionOps edu_mmio_ops &#x3D; &#123;\n    .read &#x3D; edu_mmio_read,\n    .write &#x3D; edu_mmio_write,\n    .endianness &#x3D; DEVICE_NATIVE_ENDIAN,\n    .valid &#x3D; &#123;\n        .min_access_size &#x3D; 4,\n        .max_access_size &#x3D; 8,\n    &#125;,\n    .impl &#x3D; &#123;\n        .min_access_size &#x3D; 4,\n        .max_access_size &#x3D; 8,\n    &#125;,\n\n&#125;;\n\n&#x2F;*\n * We purposely use a thread, so that users are forced to wait for the status\n * register.\n *&#x2F;\nstatic void *edu_fact_thread(void *opaque)\n&#123;\n    EduState *edu &#x3D; opaque;\n\n    while (1) &#123;\n        uint32_t val, ret &#x3D; 1;\n\n        qemu_mutex_lock(&amp;edu-&gt;thr_mutex);\n        while ((qatomic_read(&amp;edu-&gt;status) &amp; EDU_STATUS_COMPUTING) &#x3D;&#x3D; 0 &amp;&amp;\n                        !edu-&gt;stopping) &#123;\n            qemu_cond_wait(&amp;edu-&gt;thr_cond, &amp;edu-&gt;thr_mutex);\n        &#125;\n\n        if (edu-&gt;stopping) &#123;\n            qemu_mutex_unlock(&amp;edu-&gt;thr_mutex);\n            break;\n        &#125;\n\n        val &#x3D; edu-&gt;fact;\n        qemu_mutex_unlock(&amp;edu-&gt;thr_mutex);\n\n        while (val &gt; 0) &#123;\n            ret *&#x3D; val--;\n        &#125;\n\n        &#x2F;*\n         * We should sleep for a random period here, so that students are\n         * forced to check the status properly.\n         *&#x2F;\n\n        qemu_mutex_lock(&amp;edu-&gt;thr_mutex);\n        edu-&gt;fact &#x3D; ret;\n        qemu_mutex_unlock(&amp;edu-&gt;thr_mutex);\n        qatomic_and(&amp;edu-&gt;status, ~EDU_STATUS_COMPUTING);\n\n        if (qatomic_read(&amp;edu-&gt;status) &amp; EDU_STATUS_IRQFACT) &#123;\n            qemu_mutex_lock_iothread();\n            edu_raise_irq(edu, FACT_IRQ);\n            qemu_mutex_unlock_iothread();\n        &#125;\n    &#125;\n\n    return NULL;\n&#125;\n\nstatic void pci_edu_realize(PCIDevice *pdev, Error **errp)\n&#123;\n    EduState *edu &#x3D; EDU(pdev);\n    uint8_t *pci_conf &#x3D; pdev-&gt;config;\n\n    pci_config_set_interrupt_pin(pci_conf, 1);\n\n    if (msi_init(pdev, 0, 1, true, false, errp)) &#123;\n        return;\n    &#125;\n\n    timer_init_ms(&amp;edu-&gt;dma_timer, QEMU_CLOCK_VIRTUAL, edu_dma_timer, edu);\n\n    qemu_mutex_init(&amp;edu-&gt;thr_mutex);\n    qemu_cond_init(&amp;edu-&gt;thr_cond);\n    qemu_thread_create(&amp;edu-&gt;thread, &quot;edu&quot;, edu_fact_thread,\n                       edu, QEMU_THREAD_JOINABLE);\n\n    memory_region_init_io(&amp;edu-&gt;mmio, OBJECT(edu), &amp;edu_mmio_ops, edu,\n                    &quot;edu-mmio&quot;, 1 * MiB);\n    pci_register_bar(pdev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;edu-&gt;mmio);\n&#125;\n\nstatic void pci_edu_uninit(PCIDevice *pdev)\n&#123;\n    EduState *edu &#x3D; EDU(pdev);\n\n    qemu_mutex_lock(&amp;edu-&gt;thr_mutex);\n    edu-&gt;stopping &#x3D; true;\n    qemu_mutex_unlock(&amp;edu-&gt;thr_mutex);\n    qemu_cond_signal(&amp;edu-&gt;thr_cond);\n    qemu_thread_join(&amp;edu-&gt;thread);\n\n    qemu_cond_destroy(&amp;edu-&gt;thr_cond);\n    qemu_mutex_destroy(&amp;edu-&gt;thr_mutex);\n\n    timer_del(&amp;edu-&gt;dma_timer);\n    msi_uninit(pdev);\n&#125;\n\nstatic void edu_instance_init(Object *obj)\n&#123;\n    EduState *edu &#x3D; EDU(obj);\n\n    edu-&gt;dma_mask &#x3D; (1UL &lt;&lt; 28) - 1;\n    object_property_add_uint64_ptr(obj, &quot;dma_mask&quot;,\n                                   &amp;edu-&gt;dma_mask, OBJ_PROP_FLAG_READWRITE);\n&#125;\n\nstatic void edu_class_init(ObjectClass *class, void *data)\n&#123;\n    DeviceClass *dc &#x3D; DEVICE_CLASS(class);\n    PCIDeviceClass *k &#x3D; PCI_DEVICE_CLASS(class);\n\n    k-&gt;realize &#x3D; pci_edu_realize;\n    k-&gt;exit &#x3D; pci_edu_uninit;\n    k-&gt;vendor_id &#x3D; PCI_VENDOR_ID_QEMU;\n    k-&gt;device_id &#x3D; 0x11e8;\n    k-&gt;revision &#x3D; 0x10;\n    k-&gt;class_id &#x3D; PCI_CLASS_OTHERS;\n    set_bit(DEVICE_CATEGORY_MISC, dc-&gt;categories);\n&#125;\n\nstatic void pci_edu_register_types(void)\n&#123;\n    static InterfaceInfo interfaces[] &#x3D; &#123;\n        &#123; INTERFACE_CONVENTIONAL_PCI_DEVICE &#125;,\n        &#123; &#125;,\n    &#125;;\n    static const TypeInfo edu_info &#x3D; &#123;\n        .name          &#x3D; TYPE_PCI_EDU_DEVICE,\n        .parent        &#x3D; TYPE_PCI_DEVICE,\n        .instance_size &#x3D; sizeof(EduState),\n        .instance_init &#x3D; edu_instance_init,\n        .class_init    &#x3D; edu_class_init,\n        .interfaces &#x3D; interfaces,\n    &#125;;\n\n    type_register_static(&amp;edu_info);\n&#125;\ntype_init(pci_edu_register_types)\n\n","slug":"edu驱动编写之初始篇","date":"2022-11-28T16:42:13.000Z","categories_index":"edu驱动编写","tags_index":"edu,驱动,嵌入式","author_index":"Lwy"},{"id":"bc567916c4dc0d8169bd26d18e348d36","title":"test","content":"this is the first page of lwy.\n","slug":"test","date":"2022-11-23T13:23:04.000Z","categories_index":"Hexo","tags_index":"start","author_index":"Lwy"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-11-23T11:25:17.599Z","categories_index":"","tags_index":"","author_index":"Lwy"}]