{"title":"EDU驱动编写3","uid":"819ba4607ba7e42105c02b8b06201556","slug":"EDU&DMA","date":"2022-12-01T03:28:59.000Z","updated":"2023-03-16T03:34:15.772Z","comments":true,"path":"api/articles/EDU&DMA.json","keywords":null,"cover":null,"content":"<p>此前一直不太清楚DMA是个什么东西，经过小团队成员讲解还有自己查查资料，现在总算明了了：DMA不是一段内存空间！而是一个硬件设备，是用来控制数据的传输的，准确来说是一个调度器！DMA调度器的功能就是在设备需要往内存传输数据或者内存往设备传输数据的时候不需要CPU来接手，而是依靠DMA调度器来完成，这样CPU就可以在传输数据的时候也去高效执行其他任务，而不是在这当低效的搬运工了。</p>\n<p>ok! 了解了DMA是个什么，接着就来整理edu是怎么模拟DMA的。</p>\n<h1 id=\"1、寄存器\"><a href=\"#1、寄存器\" class=\"headerlink\" title=\"1、寄存器\"></a>1、寄存器</h1><p>首先，既然是搬运数据，那就肯定得要有数据的源地址、数据的目标地址、数据的大小、还有怎么触发DMA，为此，edu设备提供了四个寄存器来承担上面四个职责：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0x80 (RW) : DMA source address\n\t    Where to perform the DMA from.\n\n0x88 (RW) : DMA destination address\n\t    Where to perform the DMA to.\n\n0x90 (RW) : DMA transfer count\n\t    The size of the area to perform the DMA on.\n\n0x98 (RW) : DMA command register, bitwise OR\n\t    0x01 -- start transfer\n\t    0x02 -- direction (0: from RAM to EDU, 1: from EDU to RAM)\n\t    0x04 -- raise interrupt 0x100 after finishing the DMA<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中，0x80和0x88就是储存数据的源地址和数据的目标地址，而0x90则指示出数据的大小，最重要、复杂的0x98则承担着是否启动DMA，以何种方式运行DMA的指示责任，其中储存的二进制数末三位的作用是：</p>\n<ul>\n<li>末位：为0时关闭DMA，为1时启动DMA</li>\n<li>次末位：为0时表示数据从RAM往edu设备传输，为1时表示数据从edu设备往RAM传输</li>\n<li>倒数第三位：为1时以0x100发起中断</li>\n</ul>\n<p>也就是说，如果我们要启用DMA的功能，首先我们要在驱动里往相应的寄存器里写入数据的源地址、目标地址和数据大小，然后将0x98寄存器的二进制数末位置成1，次末位看情况置成0或1，倒数第三位则置成1，让中断可以被发起，调用中断服务函数来检查我们的DMA设备是否正常运作。这些就是我们要在驱动里干的事情。</p>\n<h1 id=\"2-edu源码\"><a href=\"#2-edu源码\" class=\"headerlink\" title=\"2. edu源码\"></a>2. edu源码</h1><p>既然要研究edu，同时理解DMA在edu里是怎么被模拟实现的，那肯定要看源码了。那从哪里开始看呢？一切的源头都是从读写寄存器开始！</p>\n<p>经过之前的研究，我们可以发现，edu这个设备几乎都是在寄存器被读写的时候才运作起来的，那我们就先来看看<code>edu_mmio_read()</code>和<code>edu_mmio_write()</code>这两个函数吧。</p>\n<p>ok，看了一圈下来，不难发现，不管是读还是写那四个寄存器，edu调用的都是同一个函数<code>dma_rw()</code>，也只有在写0x98的时候稍微多了一个判断语句，但是问题不大，我们先来看<code>dma_rw()</code>的定义：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static void dma_rw(EduState *edu, bool write, dma_addr_t *val, dma_addr_t *dma,\n                   bool timer)\n&#123;\n    if (write &amp;&amp; (edu-&gt;dma.cmd &amp; EDU_DMA_RUN))\n    &#123;\n        return;\n    &#125;\n\n    if (write)\n    &#123;\n        *dma &#x3D; *val;\n    &#125;\n    else\n    &#123;\n        *val &#x3D; *dma;\n    &#125;\n\n    if (timer)\n    &#123;\n        timer_mod(&amp;edu-&gt;dma_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + 100);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>ok，看着也不复杂，我们来仔细研究研究它干了些什么。</p>\n<p>第一个<code>if</code>语句是一个判断，首先<code>write</code>就是一个bool值，我们发现在<code>edu_mmio_read()</code>函数里这个值都是<code>false</code>，而<code>edu_mmio_write()</code>则全是<code>true</code>，那我们不妨理解成这是一个表示调用<code>dma_rw()</code>的时候是否是写寄存器的标记。那这样的话，下面第二个<code>if</code>语句读寄存器的时候就执行else的代码，返回dma指针指向的数，写的时候就执行<code>if</code>的代码，将dma指针指向新写入的数。还有我们要注意到<code>*dma</code>在写不同寄存器时代表的是不同寄存器的地址。追寻一下代码，发现写四个寄存器分别传入的是<code>&amp;edu-&gt;dma.src</code>、<code>&amp;edu-&gt;dma.dst</code>、<code>&amp;edu-&gt;dma.cnt</code>、<code>&amp;edu-&gt;dma.cmd</code>，这样就可以轻松猜想edu设备就是用了这四个变量来模拟那四个寄存器了。</p>\n<p>但是事情没有那么简单，还有一个<code>edu-&gt;dma.cmd &amp; EDU_DMA_RUN</code>不明所以。我们找找定义，发现<code>EDU_DMA_RUN</code>就是0x1，也就是说当edu-&gt;dma.cmd（也就是0x98）是0x1，并且是写寄存器时就直接退出<code>dma_rw()</code>函数了。为何要这样？不理解，但不急，我们先往下看，下面还有一个<code>timer</code>的判断，这次我们发现只有写0x98的时候，timer才是true，<code>timer_mod()</code>函数才被调用，其他时候就不会被调用。为什么只有写0x98才被调用？还有timer_mod()是干嘛的？</p>\n<p>这次我们就要查查资料了（好吧，其实我是听团队成员讲解的），<code>timer_mod()</code>函数就一个定时函数，作用就是在100ms之后调用<code>edu-&gt;dma_timer</code>这个函数，没错，edu-&gt;dma_timer是一个函数，而不是什么变量。怎么知道的？我们来找找edu源码里哪里出现了<code>edu-&gt;dma_timer</code>，我们发现了<code>timer_init_ms(&amp;edu-&gt;dma_timer, QEMU_CLOCK_VIRTUAL, edu_dma_timer, edu);</code>这个东西。</p>\n<p>这个函数是干嘛的？我们来听听我们的团队成员是怎么讲的。嗯，好，这个函数就是将<code>edu-&gt;dma_timer</code>和<code>edu_dma_timer</code>这个函数绑定起来的，因此<code>edu-&gt;dma_timer</code>就相当于一个函数啦，而且这个函数就是<code>edu_dma_timer</code>，ok，懂了，我们接着看edu_dma_timer()的定义。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static void edu_dma_timer(void *opaque)\n&#123;\n    EduState *edu &#x3D; opaque;\n    bool raise_irq &#x3D; false;\n\n    if (!(edu-&gt;dma.cmd &amp; EDU_DMA_RUN))\n    &#123;\n        return;\n    &#125;\n\n    if (EDU_DMA_DIR(edu-&gt;dma.cmd) &#x3D;&#x3D; EDU_DMA_FROM_PCI)   &#x2F;&#x2F;from RAM to edu\n    &#123;\n        uint64_t dst &#x3D; edu-&gt;dma.dst;\n        edu_check_range(dst, edu-&gt;dma.cnt, DMA_START, DMA_SIZE);\n        dst -&#x3D; DMA_START;\n        pci_dma_read(&amp;edu-&gt;pdev, edu_clamp_addr(edu, edu-&gt;dma.src),\n                     edu-&gt;dma_buf + dst, edu-&gt;dma.cnt);\n    &#125;\n    else\n    &#123;\n        uint64_t src &#x3D; edu-&gt;dma.src;\n        edu_check_range(src, edu-&gt;dma.cnt, DMA_START, DMA_SIZE);\n        src -&#x3D; DMA_START;\n        pci_dma_write(&amp;edu-&gt;pdev, edu_clamp_addr(edu, edu-&gt;dma.dst),\n                      edu-&gt;dma_buf + src, edu-&gt;dma.cnt);\n    &#125;\n\n    edu-&gt;dma.cmd &amp;&#x3D; ~EDU_DMA_RUN;\n    if (edu-&gt;dma.cmd &amp; EDU_DMA_IRQ)\n    &#123;\n        raise_irq &#x3D; true;\n    &#125;\n\n    if (raise_irq)\n    &#123;\n        edu_raise_irq(edu, DMA_IRQ);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上面我们研究过，<code>edu-&gt;dma.cmd</code>就代表了0x98寄存器，我们看第一个if语句，意思就是只有当0x98寄存器里的二进制数最末位为1，这个函数才会执行。是否有联想到什么？我们之前说明寄存器时讲过，只有当0x98最末位为1时才开启DMA，而这里也是只有最末位为1才会执行这个函数，会不会这个函数就是用来模拟DMA的？我们接着看。</p>\n<p>下面还是一个if语句，老规矩，查找<code>EDU_DMA_DIR</code>的定义：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#define EDU_DMA_DIR(cmd) (((cmd)&amp;0x2) &gt;&gt; 1)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>看起来有点复杂，其实这东西就是查看传进<code>EDU_DMA_DIR</code>的数字的倒数第二位是什么值，这里传进去的是0x98的二进制数字。然后我们知道0x98倒数第二位的数字0就代表数据从RAM传进edu，1就代表从edu传进RAM。等号后面的这个<code>EDU_DMA_FROM_PCI</code>就更是明示了这个if语句就是判断0x98的倒数第二位数字的，因为EDU_DMA_FROM_PCI的值就是0，说明倒数第二位为0时，就执行if里面的代码，为1就执行else里的代码。那就不难理解，if里的代码就是模拟数据从RAM传进edu的，而else则相反。</p>\n<p><code>edu-&gt;dma.cmd &amp;= ~EDU_DMA_RUN;</code>这句则是将0x98末位置回0，也就是DMA已经完成数据的传输了，是时候关闭DMA了。</p>\n<p>然后再下面的if语句就是判断0x98的倒数第三位是不是1，是就把<code>raise_irq</code>变成true，再下面就根据这个来判断是否调用<code>edu_raise_irq(edu, DMA_IRQ)</code>发起中断，这就对应了0x98倒数第三位数字的发中断功能了。</p>\n<p>okok，现在已经很明确了，这个<code>edu_dma_timer()</code>函数就是用来模拟DMA的功能的。我们再回过头来看<code>dma_rw()</code>这个函数，回到我们之前的问题：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">if (write &amp;&amp; (edu-&gt;dma.cmd &amp; EDU_DMA_RUN))\n    &#123;\n        return;\n    &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>为什么当<code>edu-&gt;dma.cmd</code>为1的时候就直接退出这个函数呢？我们不正是要将0x98末位置成1来开启DMA，怎么这里反倒是直接退出，不开启DMA了？</p>\n<p>不要忘记，同志们，我们是在读写寄存器的时候才触发这个函数的，同时要是写寄存器才会有可能导致函数的直接退出，而我们为什么要写寄存器？不正是要数据的源地址、目标地址、数据大小写进寄存器，同时设置0x98里的数字开启DMA嘛，这时候我们还未开启DMA啊！这说明这时候0x98里的数都是0啊，同志们！所以自然就不可能导致函数的退出咯。</p>\n<p>而会退出的时候是什么情况？必定是DMA开启了，数据正在传输中，然后我又去写了寄存器，这时候才会导致<code>dma_rw()</code>函数的直接退出。为什么会这样？我数据正在传输中欸！你写寄存器的话不就会导致我原来的数据地址那些丢失了嘛，那我还怎么传数据？所以传输数据的过程自然不能被更改寄存器了！而读的话，数据又还没传输完成，读什么呢？所以就要屏蔽掉你们对寄存器的读写操作啦！怎么屏蔽？直接退出<code>dma_rw()</code>函数不就屏蔽了，不执行这个函数你们没办法更改寄存器啊！</p>\n<p>这样的话，对edu里DMA的模拟原理也基本讲解清楚了，不过这里还有补充一个点就是，在<code>timer_mod(&amp;edu-&gt;dma_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + 100)</code>里调用<code>&amp;edu-&gt;dma_timer</code>的时候为什么要先延迟100ms呢？不能立即调用吗？这是因为在实际的设备里，当设备向CPU发出一个DMA请求的时候，CPU是不可能立即就响应，CPU会在一个合理、安全的时机来响应请求，然后才是DMA的工作时间，也就是说从设备发出请求到DMA运转起来会有延迟，这也就是100ms的奥妙所在啦！</p>\n<h1 id=\"3-驱动实现\"><a href=\"#3-驱动实现\" class=\"headerlink\" title=\"3. 驱动实现\"></a>3. 驱动实现</h1><p>在probe()函数里，在进行对四个寄存器的初始化之前，要先调用<code>pci_set_master(dev)</code>函数启用设备的总线控制，使设备能够获得总线资源。</p>\n<p>然后再调用<code>dma_set_coherent_mask(&amp;dev-&gt;dev, DMA_BIT_MASK(28))</code>来设置一致性内存掩码，使内核能够正常访问地址，参数中的掩码 28 要和 EDU 中的设置一致。</p>\n<p>为什么是28？我们且看下面的edu.c里的语句：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">edu-&gt;dma_mask &#x3D; (1UL &lt;&lt; 28) - 1;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这意思就是将edu-&gt;dma_mask的数值设成了28位1，这是edu设备设置好了的，我们只需用就行。</p>\n<p>那剩下的驱动要实现的就是对四个寄存器写数据，要传的数据写进源地址寄存器，然后再读一下目标地址寄存器，看看是不是写进去的数字，如果是，那就证明成功了！</p>\n","text":"此前一直不太清楚DMA是个什么东西，经过小团队成员讲解还有自己查查资料，现在总算明了了：DMA不是一段内存空间！而是一个硬件设备，是用来控制数据的传输的，准确来说是一个调度器！DMA调度器的功能就是在设备需要往内存传输数据或者内存往设备传输数据的时候不需要CPU来接手，而是依靠D...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"edu驱动编写","slug":"edu驱动编写","count":4,"path":"api/categories/edu驱动编写.json"}],"tags":[{"name":"edu","slug":"edu","count":4,"path":"api/tags/edu.json"},{"name":"驱动","slug":"驱动","count":3,"path":"api/tags/驱动.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">1、寄存器</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-edu%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">2. edu源码</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">3. 驱动实现</span></a></li></ol>","author":{"name":"Lwy","slug":"blog-author","avatar":"/static/img/Alimiya.png","link":"/","description":"计算机的世界如此浩瀚，我们当然要潜入其中，好好遨游啦！","socials":{"github":"https://github.com/lwyOAO","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"PCI驱动与设备交互.md","uid":"acf10ab9f32d6185e43df610ba958fe1","slug":"PCI驱动与设备交互","date":"2022-12-03T01:37:11.000Z","updated":"2023-03-16T04:03:15.684Z","comments":true,"path":"api/articles/PCI驱动与设备交互.json","keywords":null,"cover":null,"text":"PCI驱动与设备交互pci_device_id 在介绍该结构之前，让我们来看看PCI的地址空间：I&#x2F;O空间，存储空间，配置空间。 CPU 可以访问PCI设备上的所有地址空间，其中I&#x2F;O空间和存储空间提供给设备驱动程序使用，而配 置空间则由Linux内核中的PC...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"edu驱动编写","slug":"edu驱动编写","count":4,"path":"api/categories/edu驱动编写.json"}],"tags":[{"name":"edu","slug":"edu","count":4,"path":"api/tags/edu.json"}],"author":{"name":"Lwy","slug":"blog-author","avatar":"/static/img/Alimiya.png","link":"/","description":"计算机的世界如此浩瀚，我们当然要潜入其中，好好遨游啦！","socials":{"github":"https://github.com/lwyOAO","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"读写寄存器之任务1","uid":"6f627038cb98b0e4718af07882f58073","slug":"读写寄存器之任务1","date":"2022-11-30T16:42:41.000Z","updated":"2023-03-16T03:23:59.168Z","comments":true,"path":"api/articles/读写寄存器之任务1.json","keywords":null,"cover":null,"text":"在经过上一篇的简单预备之后，这篇lwy就要带着大家来真正开始研究怎么给edu设备写驱动了。 首先，lwy 认为目标驱动学习才是最高效的，特别是在计算机这个领域，要学习的知识实在是太多了，所以经常有许多同学就认为做一个项目前要先完完整整地学习一遍相应的知识才行，lwy 不是说这样不...","link":"","photos":[],"count_time":{"symbolsCount":980,"symbolsTime":"1 mins."},"categories":[{"name":"edu驱动编写","slug":"edu驱动编写","count":4,"path":"api/categories/edu驱动编写.json"}],"tags":[{"name":"edu","slug":"edu","count":4,"path":"api/tags/edu.json"},{"name":"驱动","slug":"驱动","count":3,"path":"api/tags/驱动.json"}],"author":{"name":"Lwy","slug":"blog-author","avatar":"/static/img/Alimiya.png","link":"/","description":"计算机的世界如此浩瀚，我们当然要潜入其中，好好遨游啦！","socials":{"github":"https://github.com/lwyOAO","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}