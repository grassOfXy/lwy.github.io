{"title":"PCI驱动与设备交互.md","uid":"acf10ab9f32d6185e43df610ba958fe1","slug":"PCI驱动与设备交互","date":"2022-12-03T01:37:11.000Z","updated":"2023-03-16T04:03:15.684Z","comments":true,"path":"api/articles/PCI驱动与设备交互.json","keywords":null,"cover":null,"content":"<h1 id=\"PCI驱动与设备交互\"><a href=\"#PCI驱动与设备交互\" class=\"headerlink\" title=\"PCI驱动与设备交互\"></a>PCI驱动与设备交互</h1><h2 id=\"pci-device-id\"><a href=\"#pci-device-id\" class=\"headerlink\" title=\"pci_device_id\"></a>pci_device_id</h2><ol>\n<li><p>在介绍该结构之前，让我们来看看PCI的地址空间：I&#x2F;O空间，存储空间，配置空间。 CPU 可以访问PCI设备上的所有地址空间，其中I&#x2F;O空间和存储空间提供给设备驱动程序使用，而配 置空间则由Linux内核中的PCI初始化代码使用，内核在 启动时负责对所有PCI设备进行初始化，配 置好所有的PCI设备，包括中断号以及I&#x2F;O基址，并在文件&#x2F;proc&#x2F;pci中列出所有找到的PCI设备，以 及 这些我设备的参数和属性。</p>\n</li>\n<li><p>PCI设备会用三或五个寄存器去标识一个设备，通常我们选择三个：</p>\n</li>\n</ol>\n<ul>\n<li>vendorID：标识硬件制造商，是一个16位的寄存器。 </li>\n<li>deviceID：设备ID，由制造商选择，也是一个16位的寄存器。一般与厂商ID配对生成一个唯 一的32位硬件设备标识符。 </li>\n<li>class：每个外部设备属于某个类(class)，也是一个16位的寄存器。当某个驱动程序可支持多 个相似的设备，每个具有不同的签名，但都属于同一个类，这时，就可以用class类对它们的 外设进行识别。</li>\n</ul>\n<p>   **驱动就可以通过设置这些值来匹配那些我们想要控制的设备 **</p>\n<p>   那如何设置这些值呢？ </p>\n<p>   内核为我们准备了一个数据结构：struct pci_device_id </p>\n   <pre class=\"line-numbers language-none\"><code class=\"language-none\">struct pci_device_id&#123;\n__u32 vendor;\n__32 device;\n__u32 subvendor;\n__u32 subdevice;\n__u32 class;\n__u32 class_mask;\nkernel_ulong_t driver_data;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>   一个驱动可以控制多个设备，就用到数组：</p>\n   <pre class=\"line-numbers language-none\"><code class=\"language-none\">static struct pci_device_id ids [] &#x3D;&#123;\n&#123;PCI_VENDOR_ID_EXAMPLE, PCI_DEVICE_ID_EXAMPLE,PCI_ANY_ID,PCI_ANY_ID,0,0,\nEXAMPLE&#125;,\n&#123;0,&#125;\n&#125;;\n##不管你这里匹配了多少设备，记得最后一个都是&#123;0,&#125;。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre><code>这里还有两个关于初始化该结构体的宏，可以用来简化相关的操作: \n</code></pre>\n   <pre class=\"line-numbers language-none\"><code class=\"language-none\">PCI_DEVICE(vendor, device);\n##创建一个仅和特定厂商及设备ID相匹配的struct pci_device_id。它把结构体的subvendor和\n##subdevice设为PCI_ANY_ID。PCI_ANY_ID定义：#define PCI_ANY_ID (~0)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>   我们还需要把pci_device_id数据结构暴露到用户空间来让 热插拔和模块加载系统 知道哪个模块应该 用于哪个设备。 </p>\n<p>   这一步我们用MODULE_DEVICE_TABLE函数来完成</p>\n   <pre class=\"line-numbers language-none\"><code class=\"language-none\">MODULE_DEVICE_TABLE(pci, ids); &#x2F;&#x2F;ids即为pci_device_id结构数组<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"pci-driver\"><a href=\"#pci-driver\" class=\"headerlink\" title=\"pci_driver\"></a>pci_driver</h2><p>pci_device_id 只是声明了可以识别的设备，但如何让内核去识别这些设备呢？就需要pci_driver结构体</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct pci_driver &#123;\nconst char *name;\nconst struct pci_device_id *id_table; &#x2F;&#x2F;指向pci_device_id\nint (*probe) (struct pci_dev *dev, const struct pci_device_id *id);&#x2F;&#x2F;检测设备\nvoid (*remove) (struct pci_dev *dev); &#x2F;&#x2F;卸载设备\nint (*suspend) (struct pci_dev *dev, u32 state); &#x2F;&#x2F;可选，设备被挂起时调用\nint (*resume) (struct pci_dev *dev); &#x2F;&#x2F;可选，设备唤醒时调用\n&#125;\nstatic struct pci_driver pci_driver &#x3D; &#123;\n.name &#x3D; &quot;pci_skel&quot;,\n.id_table &#x3D; ids,\n.probe &#x3D; probe,\n.remove &#x3D; remove,\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>还要注册这个驱动：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static int _ _init pci_skel_init(void)&#123;\nreturn pci_register_driver(&amp;pci_driver); &#x2F;&#x2F;注册驱动\n&#125;\nstatic void _ _exit pci_skel_exit(void)&#123;\npci_unregister_driver(&amp;pci_driver); &#x2F;&#x2F;卸载驱动\n&#125;\n&#x2F;* 加载驱动程序模块入口 *&#x2F;\nmodule_init( pci_skel_init);\n&#x2F;* 卸载驱动程序模块入口 *&#x2F;\nmodule_exit( pci_skel_exit);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"probe\"><a href=\"#probe\" class=\"headerlink\" title=\"probe\"></a>probe</h2><p>在pci_driver数据结构中定义有一个探针函数probe()，这个函数就是用于当Linux内核启动并完成对所有PCI 设备进行扫描、登录和分配资源等初始化操作并且注册了设备驱动之后，驱动用来检测设备状况的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static int __init example_probe(struct pci_dev *pci_dev,conststruct pci_device_id *pci_id) \n&#123; \n\tstruct example_pci *my_pci; \n\t&#x2F;* 启动PCI设备 *&#x2F; \n\tif(pci_enable_device(pci_dev)) return-EIO; \n\t&#x2F;* 设备DMA标识 *&#x2F; \n\tif(pci_set_dma_mask(pci_dev, EXAMPLE_DMA_MASK)) return-ENODEV; \n\t&#x2F;* 在内核空间中动态申请内存 *&#x2F; \n\tif((my_pci &#x3D; kmalloc(sizeof(struct example_pci), GFP_KERNEL))&#x3D;&#x3D; NULL)&#123;\n\t\tprintk(KERN_ERR &quot;example_pci: out of memory\\n&quot;);\n\treturn-ENOMEM;\n\t&#125;\n\tmemset(my_pci,0,sizeof(*my_pci));\n\t&#x2F;* 读取PCI配置信息 *&#x2F;\n\tmy_pci-&gt;iobase &#x3D; pci_resource_start(pci_dev,1);\n\tmy_pci-&gt;pci_dev &#x3D; pci_dev;\n\tmy_pci-&gt;pci_id &#x3D; pci_id-&gt;device;\n\tmy_pci-&gt;irq &#x3D; pci_dev-&gt;irq;\n\tmy_pci-&gt;next&#x3D; devs;\n\tmy_pci-&gt;magic &#x3D; EXAMPLE_MAGIC;\n\t&#x2F;* 设置成总线主DMA模式 *&#x2F;\n\tpci_set_master(pci_dev);\n\t&#x2F;* 申请I&#x2F;O资源 *&#x2F;\n\trequest_region(my_pci-&gt;iobase,64,my_pci_names[pci_id-&gt;driver_data]);\n\treturn 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ol>\n<li><p>pci_enable_device() 激活PCI设备，在驱动程序可以访问PCI设备的任何设备资源之前(I&#x2F;O区域或者中断)，驱动程序必须 调用该函数 2. 访问PCI地址空间在驱动程序检测到设备之后，它通常需要读取或写入三个地址空间：内存，端口和 配置。对驱动程序来说，对配置空间的访问至关重要，因为这是它找到设备映射到内存和I&#x2F;O空间的 什么位置的唯一途径。因而，首先来看看配置空间的访问：Linux内核为我们想的很周到，在内核中 就已经提供了访问配置空间的标准接口，我们只要去直接调用就好了。对于驱动程序而言，可通过8 位，16位，32位的数据传输访问配置空间。相关函数定义在中:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int pci_read_config_byte(conststruct pci_dev *dev,intwhere, u8 *val);\n&#x2F;*8位，读入一个字节*&#x2F;\nint pci_read_config_word(conststruct pci_dev *dev,intwhere, u16 *val);\n&#x2F;*16位，读入两个字节*&#x2F;\nint pci_read_config_dword(conststruct pci_dev *dev,intwhere, u32 *val);\n&#x2F;*32位，读入四个字节*&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>const struct pci_dev *dev：由dev标识的设备配置空间；  </p>\n<p>int where：从配置空间起始位置计算的字节偏移量；  </p>\n<p>u8&#x2F;u16&#x2F;u32 *val：从配置空间获得的值通过val指针返回； 函数本身返回的值是错误码。 </p>\n<p><strong>注意</strong>：word和dword函数会将读取到的little-endian值转换成处理器固有的字节序。我们自己无需处 理字节序。上面的是读  </p>\n<p>​             的情况，写的情况也是类似的. </p>\n<p>因此，我们可以利用上面的函数读取和修改设备的信息。</p>\n</li>\n</ol>\n<h2 id=\"I-x2F-O和内存空间\"><a href=\"#I-x2F-O和内存空间\" class=\"headerlink\" title=\"I&#x2F;O和内存空间\"></a>I&#x2F;O和内存空间</h2><p>一个PCI设备可实现多达6个I&#x2F;O地址区域，每个区域既可以使内存也可以是I&#x2F;O地址。在内核中PCI设 备的I&#x2F;O区域已经被集成到通用资源管理器。因此，我们无需访问配置变量来了解设备被映射到内存 或者I&#x2F;O空间的何处。获得区域信息的首选接口是下面的宏定义：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#define pci_resource_start(dev, bar)((dev)-&gt;resource[(bar)].start)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>该宏返回六个PCI I&#x2F;O区域之一的首地址(内存地址或者I&#x2F;O端口号).该区域由整数的bar(base address register，基地址寄存器)指定，bar取值为0到5。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#define pci_resource_end(dev, bar)((dev)-&gt;resource[(bar)].end)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>该宏返回第bar个I&#x2F;O区域的首地址。注意这是最后一个可用的地址，而不是该区域之后的第一个地 址</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#define pci_resource_flags(dev, bar)((dev)-&gt;resource[(bar)].flags)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>该宏返回和该资源相关联的标志。</p>\n<p><strong>分析完设备总线驱动模型，我想整个PCI驱动的框架就非常清楚了，内核启动时，会通过pci_bus之 间的关系枚举出所有的 PCI 设备，并为每一个 PCI 设备创建一个 pci_dev ，根据配置空间的信息填 充 pci_dev 之后，注册到pci_bus_type中去。而我们写的 pci_driver 在 idtable 里指定它所支持的 设备信息，同样也注册到 pci_bus_type中去，信息一致匹配成功则调用 driver-&gt;probe 函数，然后 你可以注册字符设备、块设备等等。</strong></p>\n<h2 id=\"驱动对用户的接口\"><a href=\"#驱动对用户的接口\" class=\"headerlink\" title=\"驱动对用户的接口\"></a>驱动对用户的接口</h2><p>Linux操作系统将所有的设备（而不仅是存储器里的文件）都看成文件，以操作文件的方访问设备。应用程 序不能直接操作硬件，而是使用统一的接口函数（如open、read、write等）调用硬件驱动程序。这组口被 称为系统调用，在库函数中定义。 对于上述每个系统调用，驱动程序都有一个与之对应的函数。对于字符设备驱动程序而言，这些函数集合 在一个file_operation的结构体中。在内核源码目录下\\include\\linux文件夹fs.h文件中定义。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct file_operations &#123;\nstruct module *owner;\nloff_t (*llseek) (struct file *, loff_t, int);\nssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\nssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\nssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long,\nloff_t);\nssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long,\nloff_t);\nint (*readdir) (struct file *, void *, filldir_t);\nunsigned int (*poll) (struct file *, struct poll_table_struct *);\nint (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);\nlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\nlong (*compat_ioctl) (struct file *, unsigned int, unsigned long);\nint (*mmap) (struct file *, struct vm_area_struct *);\nint (*open) (struct inode *, struct file *);\nint (*flush) (struct file *, fl_owner_t id);\nint (*release) (struct inode *, struct file *);\nint (*fsync) (struct file *, struct dentry *, int datasync);\nint (*aio_fsync) (struct kiocb *, int datasync);\nint (*fasync) (int, struct file *, int);\nint (*lock) (struct file *, int, struct file_lock *);\nssize_t (*sendfile) (struct file *, loff_t *, size_t, read_actor_t, void *);\nssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);\n常用的：\n当应用程序使用open函数打开某个设备时，设备驱动程序的file_operations结构中的open成员就会被调\n用；当应用程序使用read、write、ioctl等函数读写、控制设备时，驱动程序的file_operations 结构中的相\n应成员（read、write、ioctl等）就会被调用。从这个角度来说，编写字符设备驱动程序就是为具体硬件的\nfile_operations结构编写各个函数实体（并不需要全部实现file_operations结构中的成员）。\n因此：设备节点是上层应用和底层驱动的桥梁！\n注册字符设备\n在这里我不太清楚edu.c到底是什么类型的设备，设备类型有三种：字符设备、块设备、网络设备\n这里以字符设备为例：\n注册字符设备实际就是把设备注册成一个文件，提供设备对用户的接口，每当打开文件进行相关操作，驱\n动中对应的函数就被调用。\n其中unsigned int major是你申请的主设备号，const char *name是将要在文件&#x2F;proc&#x2F;devices中显示的名\n称，struct file_operations *fops是指向你的驱动模块的file_operations表的指针。负的返回值意味着注册失\n败。注意注册并不需要提供从设备号。内核本身并不在意从设备号。\nunsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long,\nunsigned long, unsigned long);\nint (*check_flags)(int);\nint (*dir_notify)(struct file *filp, unsigned long arg);\nint (*flock) (struct file *, int, struct file_lock *);\nssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *,\nsize_t, unsigned int);\nssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *,\nsize_t, unsigned int);\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>常用的：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static struct file_operations example_fops &#x3D;&#123;\nowner: THIS_MODULE,&#x2F;* demo_fops所属的设备模块 *&#x2F;\nread: example_read,&#x2F;* 读设备操作*&#x2F;\nwrite: example_write,&#x2F;* 写设备操作*&#x2F;\nioctl: example_ioctl,&#x2F;* 控制设备操作*&#x2F;\nopen: example_open,&#x2F;* 打开设备操作*&#x2F;\nrelease: example_release &#x2F;* 释放设备操作*&#x2F;\n&#x2F;* ... *&#x2F;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当应用程序使用open函数打开某个设备时，设备驱动程序的file_operations结构中的open成员就会被调 用；当应用程序使用read、write、ioctl等函数读写、控制设备时，驱动程序的file_operations 结构中的相 应成员（read、write、ioctl等）就会被调用。从这个角度来说，编写字符设备驱动程序就是为具体硬件的 file_operations结构编写各个函数实体（并不需要全部实现file_operations结构中的成员）。 因此：设备节点是上层应用和底层驱动的桥梁！</p>\n<h2 id=\"注册字符设备\"><a href=\"#注册字符设备\" class=\"headerlink\" title=\"注册字符设备\"></a>注册字符设备</h2><p>在这里我不太清楚edu.c到底是什么类型的设备，设备类型有三种：字符设备、块设备、网络设备 </p>\n<p>这里以字符设备为例： 注册字符设备实际就是把设备注册成一个文件，提供设备对用户的接口，每当打开文件进行相关操作，驱 动中对应的函数就被调用。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int register_chrdev(unsigned int major, const char *name, struct file_operations\n*fops)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>其中unsigned int major是你申请的主设备号，const char *name是将要在文件&#x2F;proc&#x2F;devices中显示的名 称，struct file_operations *fops是指向你的驱动模块的file_operations表的指针。负的返回值意味着注册失 败。注意注册并不需要提供从设备号。内核本身并不在意从设备号。</p>\n","feature":true,"text":"PCI驱动与设备交互pci_device_id 在介绍该结构之前，让我们来看看PCI的地址空间：I&#x2F;O空间，存储空间，配置空间。 CPU 可以访问PCI设备上的所有地址空间，其中I&#x2F;O空间和存储空间提供给设备驱动程序使用，而配 置空间则由Linux内核中的PC...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"edu驱动编写","slug":"edu驱动编写","count":4,"path":"api/categories/edu驱动编写.json"}],"tags":[{"name":"edu","slug":"edu","count":4,"path":"api/tags/edu.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#PCI%E9%A9%B1%E5%8A%A8%E4%B8%8E%E8%AE%BE%E5%A4%87%E4%BA%A4%E4%BA%92\"><span class=\"toc-text\">PCI驱动与设备交互</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#pci-device-id\"><span class=\"toc-text\">pci_device_id</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#pci-driver\"><span class=\"toc-text\">pci_driver</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#probe\"><span class=\"toc-text\">probe</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#I-x2F-O%E5%92%8C%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">I&#x2F;O和内存空间</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A9%B1%E5%8A%A8%E5%AF%B9%E7%94%A8%E6%88%B7%E7%9A%84%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">驱动对用户的接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E5%86%8C%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87\"><span class=\"toc-text\">注册字符设备</span></a></li></ol></li></ol>","author":{"name":"Lwy","slug":"blog-author","avatar":"/static/img/Alimiya.png","link":"/","description":"计算机的世界如此浩瀚，我们当然要潜入其中，好好遨游啦！","socials":{"github":"https://github.com/lwyOAO","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"排序算法效率分析","uid":"6c80c6c36e3ad5ab7314d509b34964d1","slug":"排序算法效率分析","date":"2023-02-22T04:21:47.000Z","updated":"2023-02-22T06:47:16.860Z","comments":true,"path":"api/articles/排序算法效率分析.json","keywords":null,"cover":null,"text":"排序算法复杂度总结 排序算法 平均时间复杂度 最坏时间复杂度 最好时间复杂度 空间复杂度 稳定性 冒泡排序 O(n²) O(n²) O(n) O(1) 稳定 直接选择排序 O(n²) O(n²) O(n) O(1) 不稳定 直接插入排序 O(n²) O(n²) O(n) O(1)...","link":"","photos":[],"count_time":{"symbolsCount":849,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Lwy","slug":"blog-author","avatar":"/static/img/Alimiya.png","link":"/","description":"计算机的世界如此浩瀚，我们当然要潜入其中，好好遨游啦！","socials":{"github":"https://github.com/lwyOAO","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"EDU驱动编写3","uid":"819ba4607ba7e42105c02b8b06201556","slug":"EDU&DMA","date":"2022-12-01T03:28:59.000Z","updated":"2023-03-16T03:34:15.772Z","comments":true,"path":"api/articles/EDU&DMA.json","keywords":null,"cover":null,"text":"此前一直不太清楚DMA是个什么东西，经过小团队成员讲解还有自己查查资料，现在总算明了了：DMA不是一段内存空间！而是一个硬件设备，是用来控制数据的传输的，准确来说是一个调度器！DMA调度器的功能就是在设备需要往内存传输数据或者内存往设备传输数据的时候不需要CPU来接手，而是依靠D...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"edu驱动编写","slug":"edu驱动编写","count":4,"path":"api/categories/edu驱动编写.json"}],"tags":[{"name":"edu","slug":"edu","count":4,"path":"api/tags/edu.json"},{"name":"驱动","slug":"驱动","count":3,"path":"api/tags/驱动.json"}],"author":{"name":"Lwy","slug":"blog-author","avatar":"/static/img/Alimiya.png","link":"/","description":"计算机的世界如此浩瀚，我们当然要潜入其中，好好遨游啦！","socials":{"github":"https://github.com/lwyOAO","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}