{"title":"edu驱动编写之初始篇","uid":"98fdc12e125ac5638d1042ff888f86ed","slug":"edu驱动编写之初始篇","date":"2022-11-28T16:42:13.000Z","updated":"2022-11-28T17:17:24.812Z","comments":true,"path":"api/articles/edu驱动编写之初始篇.json","keywords":null,"cover":null,"content":"<p>哎呀呀，建立了博客网站这么长时间，却没有上传任何的博客，尽管是脸皮厚如<code>lwy</code>，也有点不好意思了，所以趁着凌晨还没多困，想着最起码要把这第一篇博客要好好的写出来，所以现在尽情的爆肝吧！欧拉！</p>\n<p>因为lwy现在是跟着老师学习、研究，所以能分享的东西还是有一点的，但究竟要先分享哪些呢？想了想，还是选择驱动这一块吧，因为这应该是lwy第一次研究的算是比较深入的东西呢<code>OAO</code>（虽然对大佬来说可能还是很简单）</p>\n<p><strong>tip:</strong> 在这里要先说明的是，要写驱动就要有对应的硬件设备，而lwy 比较特殊，使用的是虚拟的设备，是由<code>qemu</code>模拟出来的<code>edu</code>设备，而不是实实在在的硬件设备，不过我相信这对于毫无编写驱动经验的小新手来说，给<code>edu</code>设备编写驱动应该是比较合适的，或者说恰到好处？因为edu设备它一开始就是用来做驱动教学用的呢，<code>edu</code>就是<code>education</code>的缩写嘛，是外国的一个大学教授专门为教导学生写驱动程序而模拟出来的虚拟设备哦。</p>\n<p>所以如果你没有编写驱动的经验，但又想初尝编写驱动程序的快乐，而且手边又没有可以用的硬件设备，那么，来加入我们吧！这里我，lwy大人，将教你使用<code>qemu</code>提供的设备来编写驱动，哇库哇库！你只需要一个<strong>装有qemu的linux系统</strong>就完全可以完成这次驱动的编写了，简单吧！嘿嘿~</p>\n<p>其次，因为是qemu模拟出来的设备，所以我们给硬件编写驱动需要看的硬件手册现在就变成了qemu里的设备源代码啦！只有看懂源代码，才能清楚我们要怎么去找到对应的寄存器啊之类的东西呢。神奇吧！用代码模拟设备，这究竟是怎么模拟的呢？接下来，lwy 也会带你去探索的哦！</p>\n<p>下面 lwy 就先给出edu设备的模拟代码吧，看看edu设备究竟是个什么东西，我们要怎么给它编驱动呢？接下来的日子里，就让我们一起开心地研究吧！(下面的代码可都是精华，要好好吸收哦！写的很棒的！)</p>\n<p>qemu&#x2F;hw&#x2F;misc&#x2F;edu.c</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;*\n * QEMU educational PCI device\n *\n * Copyright (c) 2012-2015 Jiri Slaby\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the &quot;Software&quot;),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and&#x2F;or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *&#x2F;\n\n#include &quot;qemu&#x2F;osdep.h&quot;\n#include &quot;qemu&#x2F;units.h&quot;\n#include &quot;hw&#x2F;pci&#x2F;pci.h&quot;\n#include &quot;hw&#x2F;hw.h&quot;\n#include &quot;hw&#x2F;pci&#x2F;msi.h&quot;\n#include &quot;qemu&#x2F;timer.h&quot;\n#include &quot;qom&#x2F;object.h&quot;\n#include &quot;qemu&#x2F;main-loop.h&quot; &#x2F;* iothread mutex *&#x2F;\n#include &quot;qemu&#x2F;module.h&quot;\n#include &quot;qapi&#x2F;visitor.h&quot;\n\n#define TYPE_PCI_EDU_DEVICE &quot;edu&quot;\ntypedef struct EduState EduState;\nDECLARE_INSTANCE_CHECKER(EduState, EDU,\n                         TYPE_PCI_EDU_DEVICE)\n\n#define FACT_IRQ        0x00000001\n#define DMA_IRQ         0x00000100\n\n#define DMA_START       0x40000\n#define DMA_SIZE        4096\n\nstruct EduState &#123;\n    PCIDevice pdev;\n    MemoryRegion mmio;\n\n    QemuThread thread;\n    QemuMutex thr_mutex;\n    QemuCond thr_cond;\n    bool stopping;\n\n    uint32_t addr4;\n    uint32_t fact;\n#define EDU_STATUS_COMPUTING    0x01\n#define EDU_STATUS_IRQFACT      0x80\n    uint32_t status;\n\n    uint32_t irq_status;\n\n#define EDU_DMA_RUN             0x1\n#define EDU_DMA_DIR(cmd)        (((cmd) &amp; 0x2) &gt;&gt; 1)\n# define EDU_DMA_FROM_PCI       0\n# define EDU_DMA_TO_PCI         1\n#define EDU_DMA_IRQ             0x4\n    struct dma_state &#123;\n        dma_addr_t src;\n        dma_addr_t dst;\n        dma_addr_t cnt;\n        dma_addr_t cmd;\n    &#125; dma;\n    QEMUTimer dma_timer;\n    char dma_buf[DMA_SIZE];\n    uint64_t dma_mask;\n&#125;;\n\nstatic bool edu_msi_enabled(EduState *edu)\n&#123;\n    return msi_enabled(&amp;edu-&gt;pdev);\n&#125;\n\nstatic void edu_raise_irq(EduState *edu, uint32_t val)\n&#123;\n    edu-&gt;irq_status |&#x3D; val;\n    if (edu-&gt;irq_status) &#123;\n        if (edu_msi_enabled(edu)) &#123;\n            msi_notify(&amp;edu-&gt;pdev, 0);\n        &#125; else &#123;\n            pci_set_irq(&amp;edu-&gt;pdev, 1);\n        &#125;\n    &#125;\n&#125;\n\nstatic void edu_lower_irq(EduState *edu, uint32_t val)\n&#123;\n    edu-&gt;irq_status &amp;&#x3D; ~val;\n\n    if (!edu-&gt;irq_status &amp;&amp; !edu_msi_enabled(edu)) &#123;\n        pci_set_irq(&amp;edu-&gt;pdev, 0);\n    &#125;\n&#125;\n\nstatic bool within(uint64_t addr, uint64_t start, uint64_t end)\n&#123;\n    return start &lt;&#x3D; addr &amp;&amp; addr &lt; end;\n&#125;\n\nstatic void edu_check_range(uint64_t addr, uint64_t size1, uint64_t start,\n                uint64_t size2)\n&#123;\n    uint64_t end1 &#x3D; addr + size1;\n    uint64_t end2 &#x3D; start + size2;\n\n    if (within(addr, start, end2) &amp;&amp;\n            end1 &gt; addr &amp;&amp; within(end1, start, end2)) &#123;\n        return;\n    &#125;\n\n    hw_error(&quot;EDU: DMA range 0x%016&quot;PRIx64&quot;-0x%016&quot;PRIx64\n             &quot; out of bounds (0x%016&quot;PRIx64&quot;-0x%016&quot;PRIx64&quot;)!&quot;,\n            addr, end1 - 1, start, end2 - 1);\n&#125;\n\nstatic dma_addr_t edu_clamp_addr(const EduState *edu, dma_addr_t addr)\n&#123;\n    dma_addr_t res &#x3D; addr &amp; edu-&gt;dma_mask;\n\n    if (addr !&#x3D; res) &#123;\n        printf(&quot;EDU: clamping DMA %#.16&quot;PRIx64&quot; to %#.16&quot;PRIx64&quot;!\\n&quot;, addr, res);\n    &#125;\n\n    return res;\n&#125;\n\nstatic void edu_dma_timer(void *opaque)\n&#123;\n    EduState *edu &#x3D; opaque;\n    bool raise_irq &#x3D; false;\n\n    if (!(edu-&gt;dma.cmd &amp; EDU_DMA_RUN)) &#123;\n        return;\n    &#125;\n\n    if (EDU_DMA_DIR(edu-&gt;dma.cmd) &#x3D;&#x3D; EDU_DMA_FROM_PCI) &#123;\n        uint64_t dst &#x3D; edu-&gt;dma.dst;\n        edu_check_range(dst, edu-&gt;dma.cnt, DMA_START, DMA_SIZE);\n        dst -&#x3D; DMA_START;\n        pci_dma_read(&amp;edu-&gt;pdev, edu_clamp_addr(edu, edu-&gt;dma.src),\n                edu-&gt;dma_buf + dst, edu-&gt;dma.cnt);\n    &#125; else &#123;\n        uint64_t src &#x3D; edu-&gt;dma.src;\n        edu_check_range(src, edu-&gt;dma.cnt, DMA_START, DMA_SIZE);\n        src -&#x3D; DMA_START;\n        pci_dma_write(&amp;edu-&gt;pdev, edu_clamp_addr(edu, edu-&gt;dma.dst),\n                edu-&gt;dma_buf + src, edu-&gt;dma.cnt);\n    &#125;\n\n    edu-&gt;dma.cmd &amp;&#x3D; ~EDU_DMA_RUN;\n    if (edu-&gt;dma.cmd &amp; EDU_DMA_IRQ) &#123;\n        raise_irq &#x3D; true;\n    &#125;\n\n    if (raise_irq) &#123;\n        edu_raise_irq(edu, DMA_IRQ);\n    &#125;\n&#125;\n\nstatic void dma_rw(EduState *edu, bool write, dma_addr_t *val, dma_addr_t *dma,\n                bool timer)\n&#123;\n    if (write &amp;&amp; (edu-&gt;dma.cmd &amp; EDU_DMA_RUN)) &#123;\n        return;\n    &#125;\n\n    if (write) &#123;\n        *dma &#x3D; *val;\n    &#125; else &#123;\n        *val &#x3D; *dma;\n    &#125;\n\n    if (timer) &#123;\n        timer_mod(&amp;edu-&gt;dma_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + 100);\n    &#125;\n&#125;\n\nstatic uint64_t edu_mmio_read(void *opaque, hwaddr addr, unsigned size)\n&#123;\n    EduState *edu &#x3D; opaque;\n    uint64_t val &#x3D; ~0ULL;\n\n    if (addr &lt; 0x80 &amp;&amp; size !&#x3D; 4) &#123;\n        return val;\n    &#125;\n\n    if (addr &gt;&#x3D; 0x80 &amp;&amp; size !&#x3D; 4 &amp;&amp; size !&#x3D; 8) &#123;\n        return val;\n    &#125;\n\n    switch (addr) &#123;\n    case 0x00:\n        val &#x3D; 0x010000edu;\n        break;\n    case 0x04:\n        val &#x3D; edu-&gt;addr4;\n        break;\n    case 0x08:\n        qemu_mutex_lock(&amp;edu-&gt;thr_mutex);\n        val &#x3D; edu-&gt;fact;\n        qemu_mutex_unlock(&amp;edu-&gt;thr_mutex);\n        break;\n    case 0x20:\n        val &#x3D; qatomic_read(&amp;edu-&gt;status);\n        break;\n    case 0x24:\n        val &#x3D; edu-&gt;irq_status;\n        break;\n    case 0x80:\n        dma_rw(edu, false, &amp;val, &amp;edu-&gt;dma.src, false);\n        break;\n    case 0x88:\n        dma_rw(edu, false, &amp;val, &amp;edu-&gt;dma.dst, false);\n        break;\n    case 0x90:\n        dma_rw(edu, false, &amp;val, &amp;edu-&gt;dma.cnt, false);\n        break;\n    case 0x98:\n        dma_rw(edu, false, &amp;val, &amp;edu-&gt;dma.cmd, false);\n        break;\n    &#125;\n\n    return val;\n&#125;\n\nstatic void edu_mmio_write(void *opaque, hwaddr addr, uint64_t val,\n                unsigned size)\n&#123;\n    EduState *edu &#x3D; opaque;\n\n    if (addr &lt; 0x80 &amp;&amp; size !&#x3D; 4) &#123;\n        return;\n    &#125;\n\n    if (addr &gt;&#x3D; 0x80 &amp;&amp; size !&#x3D; 4 &amp;&amp; size !&#x3D; 8) &#123;\n        return;\n    &#125;\n\n    switch (addr) &#123;\n    case 0x04:\n        edu-&gt;addr4 &#x3D; ~val;\n        break;\n    case 0x08:\n        if (qatomic_read(&amp;edu-&gt;status) &amp; EDU_STATUS_COMPUTING) &#123;\n            break;\n        &#125;\n        &#x2F;* EDU_STATUS_COMPUTING cannot go 0-&gt;1 concurrently, because it is only\n         * set in this function and it is under the iothread mutex.\n         *&#x2F;\n        qemu_mutex_lock(&amp;edu-&gt;thr_mutex);\n        edu-&gt;fact &#x3D; val;\n        qatomic_or(&amp;edu-&gt;status, EDU_STATUS_COMPUTING);\n        qemu_cond_signal(&amp;edu-&gt;thr_cond);\n        qemu_mutex_unlock(&amp;edu-&gt;thr_mutex);\n        break;\n    case 0x20:\n        if (val &amp; EDU_STATUS_IRQFACT) &#123;\n            qatomic_or(&amp;edu-&gt;status, EDU_STATUS_IRQFACT);\n        &#125; else &#123;\n            qatomic_and(&amp;edu-&gt;status, ~EDU_STATUS_IRQFACT);\n        &#125;\n        break;\n    case 0x60:\n        edu_raise_irq(edu, val);\n        break;\n    case 0x64:\n        edu_lower_irq(edu, val);\n        break;\n    case 0x80:\n        dma_rw(edu, true, &amp;val, &amp;edu-&gt;dma.src, false);\n        break;\n    case 0x88:\n        dma_rw(edu, true, &amp;val, &amp;edu-&gt;dma.dst, false);\n        break;\n    case 0x90:\n        dma_rw(edu, true, &amp;val, &amp;edu-&gt;dma.cnt, false);\n        break;\n    case 0x98:\n        if (!(val &amp; EDU_DMA_RUN)) &#123;\n            break;\n        &#125;\n        dma_rw(edu, true, &amp;val, &amp;edu-&gt;dma.cmd, true);\n        break;\n    &#125;\n&#125;\n\nstatic const MemoryRegionOps edu_mmio_ops &#x3D; &#123;\n    .read &#x3D; edu_mmio_read,\n    .write &#x3D; edu_mmio_write,\n    .endianness &#x3D; DEVICE_NATIVE_ENDIAN,\n    .valid &#x3D; &#123;\n        .min_access_size &#x3D; 4,\n        .max_access_size &#x3D; 8,\n    &#125;,\n    .impl &#x3D; &#123;\n        .min_access_size &#x3D; 4,\n        .max_access_size &#x3D; 8,\n    &#125;,\n\n&#125;;\n\n&#x2F;*\n * We purposely use a thread, so that users are forced to wait for the status\n * register.\n *&#x2F;\nstatic void *edu_fact_thread(void *opaque)\n&#123;\n    EduState *edu &#x3D; opaque;\n\n    while (1) &#123;\n        uint32_t val, ret &#x3D; 1;\n\n        qemu_mutex_lock(&amp;edu-&gt;thr_mutex);\n        while ((qatomic_read(&amp;edu-&gt;status) &amp; EDU_STATUS_COMPUTING) &#x3D;&#x3D; 0 &amp;&amp;\n                        !edu-&gt;stopping) &#123;\n            qemu_cond_wait(&amp;edu-&gt;thr_cond, &amp;edu-&gt;thr_mutex);\n        &#125;\n\n        if (edu-&gt;stopping) &#123;\n            qemu_mutex_unlock(&amp;edu-&gt;thr_mutex);\n            break;\n        &#125;\n\n        val &#x3D; edu-&gt;fact;\n        qemu_mutex_unlock(&amp;edu-&gt;thr_mutex);\n\n        while (val &gt; 0) &#123;\n            ret *&#x3D; val--;\n        &#125;\n\n        &#x2F;*\n         * We should sleep for a random period here, so that students are\n         * forced to check the status properly.\n         *&#x2F;\n\n        qemu_mutex_lock(&amp;edu-&gt;thr_mutex);\n        edu-&gt;fact &#x3D; ret;\n        qemu_mutex_unlock(&amp;edu-&gt;thr_mutex);\n        qatomic_and(&amp;edu-&gt;status, ~EDU_STATUS_COMPUTING);\n\n        if (qatomic_read(&amp;edu-&gt;status) &amp; EDU_STATUS_IRQFACT) &#123;\n            qemu_mutex_lock_iothread();\n            edu_raise_irq(edu, FACT_IRQ);\n            qemu_mutex_unlock_iothread();\n        &#125;\n    &#125;\n\n    return NULL;\n&#125;\n\nstatic void pci_edu_realize(PCIDevice *pdev, Error **errp)\n&#123;\n    EduState *edu &#x3D; EDU(pdev);\n    uint8_t *pci_conf &#x3D; pdev-&gt;config;\n\n    pci_config_set_interrupt_pin(pci_conf, 1);\n\n    if (msi_init(pdev, 0, 1, true, false, errp)) &#123;\n        return;\n    &#125;\n\n    timer_init_ms(&amp;edu-&gt;dma_timer, QEMU_CLOCK_VIRTUAL, edu_dma_timer, edu);\n\n    qemu_mutex_init(&amp;edu-&gt;thr_mutex);\n    qemu_cond_init(&amp;edu-&gt;thr_cond);\n    qemu_thread_create(&amp;edu-&gt;thread, &quot;edu&quot;, edu_fact_thread,\n                       edu, QEMU_THREAD_JOINABLE);\n\n    memory_region_init_io(&amp;edu-&gt;mmio, OBJECT(edu), &amp;edu_mmio_ops, edu,\n                    &quot;edu-mmio&quot;, 1 * MiB);\n    pci_register_bar(pdev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;edu-&gt;mmio);\n&#125;\n\nstatic void pci_edu_uninit(PCIDevice *pdev)\n&#123;\n    EduState *edu &#x3D; EDU(pdev);\n\n    qemu_mutex_lock(&amp;edu-&gt;thr_mutex);\n    edu-&gt;stopping &#x3D; true;\n    qemu_mutex_unlock(&amp;edu-&gt;thr_mutex);\n    qemu_cond_signal(&amp;edu-&gt;thr_cond);\n    qemu_thread_join(&amp;edu-&gt;thread);\n\n    qemu_cond_destroy(&amp;edu-&gt;thr_cond);\n    qemu_mutex_destroy(&amp;edu-&gt;thr_mutex);\n\n    timer_del(&amp;edu-&gt;dma_timer);\n    msi_uninit(pdev);\n&#125;\n\nstatic void edu_instance_init(Object *obj)\n&#123;\n    EduState *edu &#x3D; EDU(obj);\n\n    edu-&gt;dma_mask &#x3D; (1UL &lt;&lt; 28) - 1;\n    object_property_add_uint64_ptr(obj, &quot;dma_mask&quot;,\n                                   &amp;edu-&gt;dma_mask, OBJ_PROP_FLAG_READWRITE);\n&#125;\n\nstatic void edu_class_init(ObjectClass *class, void *data)\n&#123;\n    DeviceClass *dc &#x3D; DEVICE_CLASS(class);\n    PCIDeviceClass *k &#x3D; PCI_DEVICE_CLASS(class);\n\n    k-&gt;realize &#x3D; pci_edu_realize;\n    k-&gt;exit &#x3D; pci_edu_uninit;\n    k-&gt;vendor_id &#x3D; PCI_VENDOR_ID_QEMU;\n    k-&gt;device_id &#x3D; 0x11e8;\n    k-&gt;revision &#x3D; 0x10;\n    k-&gt;class_id &#x3D; PCI_CLASS_OTHERS;\n    set_bit(DEVICE_CATEGORY_MISC, dc-&gt;categories);\n&#125;\n\nstatic void pci_edu_register_types(void)\n&#123;\n    static InterfaceInfo interfaces[] &#x3D; &#123;\n        &#123; INTERFACE_CONVENTIONAL_PCI_DEVICE &#125;,\n        &#123; &#125;,\n    &#125;;\n    static const TypeInfo edu_info &#x3D; &#123;\n        .name          &#x3D; TYPE_PCI_EDU_DEVICE,\n        .parent        &#x3D; TYPE_PCI_DEVICE,\n        .instance_size &#x3D; sizeof(EduState),\n        .instance_init &#x3D; edu_instance_init,\n        .class_init    &#x3D; edu_class_init,\n        .interfaces &#x3D; interfaces,\n    &#125;;\n\n    type_register_static(&amp;edu_info);\n&#125;\ntype_init(pci_edu_register_types)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","text":"哎呀呀，建立了博客网站这么长时间，却没有上传任何的博客，尽管是脸皮厚如lwy，也有点不好意思了，所以趁着凌晨还没多困，想着最起码要把这第一篇博客要好好的写出来，所以现在尽情的爆肝吧！欧拉！ 因为lwy现在是跟着老师学习、研究，所以能分享的东西还是有一点的，但究竟要先分享哪些呢？想...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"edu驱动编写","slug":"edu驱动编写","count":2,"path":"api/categories/edu驱动编写.json"}],"tags":[{"name":"edu","slug":"edu","count":2,"path":"api/tags/edu.json"},{"name":"驱动","slug":"驱动","count":2,"path":"api/tags/驱动.json"},{"name":"嵌入式","slug":"嵌入式","count":1,"path":"api/tags/嵌入式.json"}],"toc":"","author":{"name":"Lwy","slug":"blog-author","avatar":"/static/img/Alimiya.png","link":"/","description":"计算机的世界如此浩瀚，我们当然要潜入其中，好好遨游啦！","socials":{"github":"https://github.com/lwyOAO","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"读写寄存器之任务1","uid":"6f627038cb98b0e4718af07882f58073","slug":"读写寄存器之任务1","date":"2022-11-30T16:42:41.000Z","updated":"2022-11-30T17:25:43.690Z","comments":true,"path":"api/articles/读写寄存器之任务1.json","keywords":null,"cover":null,"text":"在经过上一篇的简单预备之后，这篇lwy就要带着大家来真正开始研究怎么给edu设备写驱动了。 首先，lwy 认为目标驱动学习才是最高效的，特别是在计算机这个领域，要学习的知识实在是太多了，所以经常有许多同学就认为做一个项目前要先完完整整地学习一遍相应的知识才行，lwy 不是说这样不...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"edu驱动编写","slug":"edu驱动编写","count":2,"path":"api/categories/edu驱动编写.json"}],"tags":[{"name":"edu","slug":"edu","count":2,"path":"api/tags/edu.json"},{"name":"驱动","slug":"驱动","count":2,"path":"api/tags/驱动.json"}],"author":{"name":"Lwy","slug":"blog-author","avatar":"/static/img/Alimiya.png","link":"/","description":"计算机的世界如此浩瀚，我们当然要潜入其中，好好遨游啦！","socials":{"github":"https://github.com/lwyOAO","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"test","uid":"bc567916c4dc0d8169bd26d18e348d36","slug":"test","date":"2022-11-23T13:23:04.000Z","updated":"2022-11-25T16:07:54.523Z","comments":true,"path":"api/articles/test.json","keywords":null,"cover":null,"text":"this is the first page of lwy. ","link":"","photos":[],"count_time":{"symbolsCount":31,"symbolsTime":"1 mins."},"categories":[{"name":"Hexo","slug":"Hexo","count":1,"path":"api/categories/Hexo.json"}],"tags":[{"name":"start","slug":"start","count":1,"path":"api/tags/start.json"}],"author":{"name":"Lwy","slug":"blog-author","avatar":"/static/img/Alimiya.png","link":"/","description":"计算机的世界如此浩瀚，我们当然要潜入其中，好好遨游啦！","socials":{"github":"https://github.com/lwyOAO","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}