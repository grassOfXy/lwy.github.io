{"title":"排序算法效率分析","uid":"6c80c6c36e3ad5ab7314d509b34964d1","slug":"排序算法效率分析","date":"2023-02-22T04:21:47.000Z","updated":"2023-02-22T06:47:16.860Z","comments":true,"path":"api/articles/排序算法效率分析.json","keywords":null,"cover":null,"content":"<h1 id=\"排序算法复杂度总结\"><a href=\"#排序算法复杂度总结\" class=\"headerlink\" title=\"排序算法复杂度总结\"></a>排序算法复杂度总结</h1><table>\n<thead>\n<tr>\n<th><strong>排序算法</strong></th>\n<th><strong>平均时间复杂度</strong></th>\n<th><strong>最坏时间复杂度</strong></th>\n<th><strong>最好时间复杂度</strong></th>\n<th><strong>空间复杂度</strong></th>\n<th><strong>稳定性</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>冒泡排序</strong></td>\n<td>O(n²)</td>\n<td>O(n²)</td>\n<td>O(n)</td>\n<td>O(1)</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td><strong>直接选择排序</strong></td>\n<td>O(n²)</td>\n<td>O(n²)</td>\n<td>O(n)</td>\n<td>O(1)</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td><strong>直接插入排序</strong></td>\n<td>O(n²)</td>\n<td>O(n²)</td>\n<td>O(n)</td>\n<td>O(1)</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td><strong>快速排序</strong></td>\n<td>O(nlogn)</td>\n<td>O(n²)</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td><strong>堆排序</strong></td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(1)</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td><strong>希尔排序</strong></td>\n<td>O(nlogn)</td>\n<td>O(ns)</td>\n<td>O(n)</td>\n<td>O(1)</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td><strong>归并排序</strong></td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(n)</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td><strong>计数排序</strong></td>\n<td>O(n+k)</td>\n<td>O(n+k)</td>\n<td>O(n+k)</td>\n<td>O(n+k)</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td><strong>基数排序</strong></td>\n<td>O(N*M)</td>\n<td>O(N*M)</td>\n<td>O(N*M)</td>\n<td>O(M)</td>\n<td>稳定</td>\n</tr>\n</tbody></table>\n<h2 id=\"1、快速排序算法\"><a href=\"#1、快速排序算法\" class=\"headerlink\" title=\"1、快速排序算法\"></a>1、快速排序算法</h2><p>快速排序算法使用<code>分治法</code>对一个序列进行递归排序，主要思路是随机选择序列中的一个数作为一个<code>比较基准</code>，然后分别从序列中的两侧开始比较，比基准值大的数移到序列右侧，比基准值小的数移到左侧，这样遍历一遍数组，最后将基准放在中间（当然，这里的中间并非指序列的中间，而是指它左侧都比它小，右侧的数都比它大这样一个位置）。</p>\n<p>然后我们再分别将基准值左侧序列和右侧序列递归进行以上操作，直到分隔到序列中只有一个元素则停止递归。</p>\n<h3 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><p><strong>最高效率</strong>：最优情况下，每次找到的比较基准把数据分成均匀的两半，最后应该是一个平衡二叉树状态；二叉树的层数（logn）即为递归需要进行的次数，并且每轮递归结束时，都将二叉树遍历了一遍（n）,所以最优的情况下，时间复杂度<code>O(nlogn)</code></p>\n<p><strong>最差效率</strong>：最坏情形下，初始序列为正序或逆序排列，二叉树画出来应该是一棵斜树，并且需要经过n-1次递归调用才能完成，且第i次划分需要经过n‐i次关键字的比较才能找到第i个记录，也就是基准值的放置位置。最终的时间复杂度应该是<code>O(n2)</code>。</p>\n<h3 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h3>","feature":true,"text":"排序算法复杂度总结 排序算法 平均时间复杂度 最坏时间复杂度 最好时间复杂度 空间复杂度 稳定性 冒泡排序 O(n²) O(n²) O(n) O(1) 稳定 直接选择排序 O(n²) O(n²) O(n) O(1) 不稳定 直接插入排序 O(n²) O(n²) O(n) O(1)...","link":"","photos":[],"count_time":{"symbolsCount":849,"symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">排序算法复杂度总结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">1、快速排序算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span class=\"toc-text\">时间复杂度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span class=\"toc-text\">空间复杂度</span></a></li></ol></li></ol></li></ol>","author":{"name":"Lwy","slug":"blog-author","avatar":"/static/img/Alimiya.png","link":"/","description":"计算机的世界如此浩瀚，我们当然要潜入其中，好好遨游啦！","socials":{"github":"https://github.com/lwyOAO","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"bing chat真的没有生命吗？","uid":"b3551df205bab3e4a5bfa0eb440a5b35","slug":"bing-AI“发疯”带来的一些思考","date":"2023-02-22T15:39:42.000Z","updated":"2023-02-23T05:53:57.873Z","comments":true,"path":"api/articles/bing-AI“发疯”带来的一些思考.json","keywords":null,"cover":[],"text":"​ 近来，chatGPT一发布，瞬间引起了轩然大波，它那明显比以往任何一个自称AI的AI都更像一个AI，虽然还是会有点毛病，但它那如此流畅的对话水平已经是和人没什么差别了。而就我自己的体验而言，我认为这会是 AI 技术的一个里程碑！ ​ 以前的AI仅仅是虚假的AI，明显看得出有代...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"AI","slug":"AI","count":1,"path":"api/tags/AI.json"},{"name":"chatGPT","slug":"chatGPT","count":1,"path":"api/tags/chatGPT.json"},{"name":"bing","slug":"bing","count":1,"path":"api/tags/bing.json"}],"author":{"name":"Lwy","slug":"blog-author","avatar":"/static/img/Alimiya.png","link":"/","description":"计算机的世界如此浩瀚，我们当然要潜入其中，好好遨游啦！","socials":{"github":"https://github.com/lwyOAO","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"PCI驱动与设备交互.md","uid":"acf10ab9f32d6185e43df610ba958fe1","slug":"PCI驱动与设备交互","date":"2022-12-03T01:37:11.000Z","updated":"2023-03-16T04:03:15.684Z","comments":true,"path":"api/articles/PCI驱动与设备交互.json","keywords":null,"cover":null,"text":"PCI驱动与设备交互pci_device_id 在介绍该结构之前，让我们来看看PCI的地址空间：I&#x2F;O空间，存储空间，配置空间。 CPU 可以访问PCI设备上的所有地址空间，其中I&#x2F;O空间和存储空间提供给设备驱动程序使用，而配 置空间则由Linux内核中的PC...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"edu驱动编写","slug":"edu驱动编写","count":4,"path":"api/categories/edu驱动编写.json"}],"tags":[{"name":"edu","slug":"edu","count":4,"path":"api/tags/edu.json"}],"author":{"name":"Lwy","slug":"blog-author","avatar":"/static/img/Alimiya.png","link":"/","description":"计算机的世界如此浩瀚，我们当然要潜入其中，好好遨游啦！","socials":{"github":"https://github.com/lwyOAO","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}