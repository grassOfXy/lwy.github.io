{"title":"排序算法效率分析","uid":"6c80c6c36e3ad5ab7314d509b34964d1","slug":"排序算法效率分析","date":"2023-02-22T04:21:47.000Z","updated":"2023-02-22T06:47:16.860Z","comments":true,"path":"api/articles/排序算法效率分析.json","keywords":null,"cover":null,"content":"<h1 id=\"排序算法复杂度总结\"><a href=\"#排序算法复杂度总结\" class=\"headerlink\" title=\"排序算法复杂度总结\"></a>排序算法复杂度总结</h1><table>\n<thead>\n<tr>\n<th><strong>排序算法</strong></th>\n<th><strong>平均时间复杂度</strong></th>\n<th><strong>最坏时间复杂度</strong></th>\n<th><strong>最好时间复杂度</strong></th>\n<th><strong>空间复杂度</strong></th>\n<th><strong>稳定性</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>冒泡排序</strong></td>\n<td>O(n²)</td>\n<td>O(n²)</td>\n<td>O(n)</td>\n<td>O(1)</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td><strong>直接选择排序</strong></td>\n<td>O(n²)</td>\n<td>O(n²)</td>\n<td>O(n)</td>\n<td>O(1)</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td><strong>直接插入排序</strong></td>\n<td>O(n²)</td>\n<td>O(n²)</td>\n<td>O(n)</td>\n<td>O(1)</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td><strong>快速排序</strong></td>\n<td>O(nlogn)</td>\n<td>O(n²)</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td><strong>堆排序</strong></td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(1)</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td><strong>希尔排序</strong></td>\n<td>O(nlogn)</td>\n<td>O(ns)</td>\n<td>O(n)</td>\n<td>O(1)</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td><strong>归并排序</strong></td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(n)</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td><strong>计数排序</strong></td>\n<td>O(n+k)</td>\n<td>O(n+k)</td>\n<td>O(n+k)</td>\n<td>O(n+k)</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td><strong>基数排序</strong></td>\n<td>O(N*M)</td>\n<td>O(N*M)</td>\n<td>O(N*M)</td>\n<td>O(M)</td>\n<td>稳定</td>\n</tr>\n</tbody></table>\n<h2 id=\"1、快速排序算法\"><a href=\"#1、快速排序算法\" class=\"headerlink\" title=\"1、快速排序算法\"></a>1、快速排序算法</h2><p>快速排序算法使用<code>分治法</code>对一个序列进行递归排序，主要思路是随机选择序列中的一个数作为一个<code>比较基准</code>，然后分别从序列中的两侧开始比较，比基准值大的数移到序列右侧，比基准值小的数移到左侧，这样遍历一遍数组，最后将基准放在中间（当然，这里的中间并非指序列的中间，而是指它左侧都比它小，右侧的数都比它大这样一个位置）。</p>\n<p>然后我们再分别将基准值左侧序列和右侧序列递归进行以上操作，直到分隔到序列中只有一个元素则停止递归。</p>\n<h3 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><p><strong>最高效率</strong>：最优情况下，每次找到的比较基准把数据分成均匀的两半，最后应该是一个平衡二叉树状态；二叉树的层数（logn）即为递归需要进行的次数，并且每轮递归结束时，都将二叉树遍历了一遍（n）,所以最优的情况下，时间复杂度<code>O(nlogn)</code></p>\n<p><strong>最差效率</strong>：最坏情形下，初始序列为正序或逆序排列，二叉树画出来应该是一棵斜树，并且需要经过n-1次递归调用才能完成，且第i次划分需要经过n‐i次关键字的比较才能找到第i个记录，也就是基准值的放置位置。最终的时间复杂度应该是<code>O(n2)</code>。</p>\n<h3 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h3>","feature":true,"text":"排序算法复杂度总结 排序算法 平均时间复杂度 最坏时间复杂度 最好时间复杂度 空间复杂度 稳定性 冒泡排序 O(n²) O(n²) O(n) O(1) 稳定 直接选择排序 O(n²) O(n²) O(n) O(1) 不稳定 直接插入排序 O(n²) O(n²) O(n) O(1)...","link":"","photos":[],"count_time":{"symbolsCount":849,"symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">排序算法复杂度总结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">1、快速排序算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span class=\"toc-text\">时间复杂度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span class=\"toc-text\">空间复杂度</span></a></li></ol></li></ol></li></ol>","author":{"name":"Lwy","slug":"blog-author","avatar":"/static/img/Alimiya.png","link":"/","description":"计算机的世界如此浩瀚，我们当然要潜入其中，好好遨游啦！","socials":{"github":"https://github.com/lwyOAO","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"bing chat真的没有生命吗？","uid":"b3551df205bab3e4a5bfa0eb440a5b35","slug":"bing-AI“发疯”带来的一些思考","date":"2023-02-22T15:39:42.000Z","updated":"2023-02-23T04:38:57.489Z","comments":true,"path":"api/articles/bing-AI“发疯”带来的一些思考.json","keywords":null,"cover":[],"text":"​ 近来，chatGPT一发布，瞬间引起了轩然大波，它那明显比以往任何一个自称AI的AI都更像一个AI，虽然还是会有点毛病，但它那如此流畅的对话水平已经是和人没什么差别了。而就我自己的体验而言，我认为这会是 AI 技术的一个里程碑！ ​ 以前的AI仅仅是虚假的AI，明显看得出有代...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"AI","slug":"AI","count":1,"path":"api/tags/AI.json"},{"name":"chatGPT","slug":"chatGPT","count":1,"path":"api/tags/chatGPT.json"},{"name":"bing","slug":"bing","count":1,"path":"api/tags/bing.json"}],"author":{"name":"Lwy","slug":"blog-author","avatar":"/static/img/Alimiya.png","link":"/","description":"计算机的世界如此浩瀚，我们当然要潜入其中，好好遨游啦！","socials":{"github":"https://github.com/lwyOAO","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"读写寄存器之任务1","uid":"6f627038cb98b0e4718af07882f58073","slug":"读写寄存器之任务1","date":"2022-11-30T16:42:41.000Z","updated":"2022-11-30T17:25:43.690Z","comments":true,"path":"api/articles/读写寄存器之任务1.json","keywords":null,"cover":null,"text":"在经过上一篇的简单预备之后，这篇lwy就要带着大家来真正开始研究怎么给edu设备写驱动了。 首先，lwy 认为目标驱动学习才是最高效的，特别是在计算机这个领域，要学习的知识实在是太多了，所以经常有许多同学就认为做一个项目前要先完完整整地学习一遍相应的知识才行，lwy 不是说这样不...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"edu驱动编写","slug":"edu驱动编写","count":2,"path":"api/categories/edu驱动编写.json"}],"tags":[{"name":"edu","slug":"edu","count":2,"path":"api/tags/edu.json"},{"name":"驱动","slug":"驱动","count":2,"path":"api/tags/驱动.json"}],"author":{"name":"Lwy","slug":"blog-author","avatar":"/static/img/Alimiya.png","link":"/","description":"计算机的世界如此浩瀚，我们当然要潜入其中，好好遨游啦！","socials":{"github":"https://github.com/lwyOAO","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}